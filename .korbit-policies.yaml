version: '0.1'

topics:
  - name: "4.0. Language Independent Issues"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 0.0.1 - Functions Shall Not Contain Unreachable Statements"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A function shall not contain any unreachable statements.
          A statement is unreachable if the block containing it cannot be reached
          from the function’s entry block in the Control Flow Graph (CFG).
        impact: |
          Unreachable code indicates dead logic or incorrect control flow.
          It can hide real bugs, bloat binaries, and confuse maintainers.
          Removing unreachable statements improves code clarity, testability, and MISRA compliance.
        code_examples:
          # C++ examples
          - non_compliant: |
              void foo() {
                  do_something();
                  return;
                  int x = 5;     // ← unreachable
                  x++;
              }
            compliant: |
              void foo() {
                  do_something();
                  return;
              }

      - title: "Rule 0.0.2 - Controlling Expressions Shall Not Be Invariant"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Controlling expressions of `if`, `while`, `for`, `do…while`, and `switch` statements, 
          the first operand of `?:`, and the left-hand operand of `&&` or `||` must not be invariant 
          (i.e. always true or always false).  
          This rule does **not** apply to controlling expressions in `constexpr if` statements.
        impact: |
          Invariant conditions often signal dead code or logic errors, reducing test coverage 
          and maintainability. Ensuring control expressions can vary at runtime improves correctness 
          and prevents unexpected behavior.
          
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <iostream>

              int main() {
                  // always-true literal condition ⇒ invariant
                  if (5 > 3) {
                      std::cout << "This always prints\n";
                  }
                  return 0;
              }
            compliant: |
              #include <iostream>
              #include <cstdlib>

              int main(int argc, char* argv[]) {
                  if (argc < 2) {
                      std::cerr << "Usage: " << argv[0] << " <divisor>\n";
                      return 1;
                  }
                  int divisor = std::atoi(argv[1]);   // varies at runtime
                  int sum = divisor * 2 + 1;
                  // now the condition truly depends on input
                  if ((sum % divisor) == 0) {
                      std::cout << "Divides evenly\n";
                  }
                  return 0;
              }

      - title: "Rule 0.1.1 - A Value Shall Not Be Unnecessarily Written to a Local Object"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A write to a local object that is never read, or is overwritten before any read,
          is unnecessary. This applies to automatic objects, arrays, and STL containers
          of trivially destructible types. An object is “unnecessarily written” if on every
          feasible control-flow path it is destroyed before a read or assigned again before a read.
        impact: |
          Unnecessary writes bloat code, hide defects, and degrade maintainability.
          Eliminating them improves clarity and uncovers latent bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              int32_t f1(int32_t j) {
                  int32_t i = j;      // initial write never used
                  i = j + 1;          // overwritten before any read
                  return i;
              }
            compliant: |
              #include <cstdint>

              int32_t f2(int32_t j) {
                  int32_t i = j;      // write is observed in return
                  return i;
              }

 
      - title: "Rule 0.1.2 - The Value Returned by a Function Shall Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any non-void function call must have its return value used.
          If you genuinely intend to ignore the result, it must be explicitly cast to `void`.
          This rule applies only when invoking a function with the usual call syntax;
          overloaded operators are exempt (they behave like built-ins).
        impact: |
          Ensuring return values are handled or explicitly discarded improves code correctness and clarity.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              uint16_t func() { return 42; }
              void f1() {
                  func();           // non-compliant: return value discarded implicitly
              }
            compliant: |
              #include <cstdint>

              uint16_t func() { return 42; }
              void f2() {
                  (void)func();     // compliant: explicit discard
                  auto result = func();  // compliant: used as initializer
              }
  
      - title: "Rule 0.2.1 - Variables with Limited Visibility Shall Be Used at Least Once"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A variable with limited visibility (internal linkage or no linkage) must be used at least once 
          within its translation unit.  

          Exceptions:
          • Variables annotated `[[maybe_unused]]`.  
          • Constant objects at namespace scope declared in header files.  
        impact: |
          Unused variables bloat the codebase, confuse maintainers and can mask real defects.  
          Ensuring each declared variable is actually used improves clarity and detects missing logic.
        code_examples:
          # C++ examples
          - non_compliant: |
              namespace {
                  int counter;       // never read or written after declaration
              }
            compliant: |
              namespace {
                  int counter;       
                  void bump() { ++counter; }  // counter is now used
              }

      - title: "Rule 0.2.2 - A Named Function Parameter Shall Be Used at Least Once"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every named parameter of a function (or lambda) must be used within the function body.
          Parameters declared `[[maybe_unused]]` are exempt.
        impact: |
          Unused parameters often indicate mismatches between interface and implementation,
          leading to dead code or overlooked logic. Ensuring each parameter is used
          maintains API consistency and uncovers potential defects.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct B {
                  virtual int16_t f(int16_t a, int16_t b) = 0;
              };
              struct D1 : B {
                  int16_t f(int16_t a, int16_t b) override {
                      return a;   // 'b' is never used → violation
                  }
              }
            compliant: |
              struct D2 : B {
                  int16_t f(int16_t a, int16_t /*b*/) override {
                      return a;   // 'b' purposefully unnamed (exempt)
                  }
              }

      - title: "Rule 0.2.3 - Types with Limited Visibility Shall Be Used at Least Once"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A type declared in block scope or an unnamed namespace must be referenced at least once within the translation unit.
          An enumeration is “used” if any enumerator is referenced.
          An alias or primary class template is “used” if instantiated or otherwise referenced.
          Exceptions:
          • Types annotated `[[maybe_unused]]`.
          • Template parameters.
          • Partial or explicit specializations of class templates.
        impact: |
          Unused types clutter the codebase and confuse reviewers.
          Ensuring each declared type is used improves clarity and maintainability.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f1() {
                  using T1 = int16_t;   // T1 never used → violation
              }
            compliant: |
              void f2() {
                  using T1 = int16_t;
                  T1 value = 0;         // T1 is used
              }

      - title: "Rule 0.2.4 - Functions with Limited Visibility Shall Be Used at Least Once"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A function declared with internal linkage (e.g. in an unnamed namespace,
          as a `static` free function, or as a private non-virtual member) must
          be called or have its address taken at least once within its translation unit.

          Exceptions:
          • Special member functions (`= default`, `= delete`, constructors, destructors).  
          • Functions annotated `[[maybe_unused]]`.  
        impact: |
          Unused internally-linked functions bloat the codebase and may hide missing
          calls that break functionality. Ensuring each such function is used
          improves code quality and uncovers dead code.
        code_examples:
          # C++ examples
          - non_compliant: |
              namespace {
                  void helper() {           // never called → violation
                      // ...
                  }
              }
            compliant: |
              namespace {
                  void helper() {
                      // ...
                  }
                  void caller() {
                      helper();            // helper is now used
                  }
              }

      - title: "Dir 0.3.1a - Floating-Point Comparison to NaN Shall Not Use `==` or `!=`"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A floating-point value shall not be compared directly to NaN using the
          equality operators `==` or `!=`.
        impact: |
          Direct comparisons to NaN always yield false and conceal invalid values.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <limits>
              bool myIsNaN(double d) {
                  return d == std::numeric_limits<double>::quiet_NaN();  // always false
              }
            compliant: |
              #include <cmath>
              bool myIsNaN(double d) {
                  return std::isnan(d);  // correct NaN check
              }

      - title: "Dir 0.3.1b - Floating-Point Arithmetic Shall Guard Against Overflow/Underflow"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Floating-point calculations shall be structured to avoid unguarded overflow
          and underflow by scaling operands or checking ranges before computation.
        impact: |
          Guarding arithmetic prevents undefined behavior due to extreme intermediate values.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f(float f1, float f2, float f3) {
                  float f4 = (f1 * f2) * f3;  // may overflow then underflow
              }
            compliant: |
              void f(float f1, float f2, float f3) {
                  double temp = static_cast<double>(f1) * f2 * f3;
                  float f4 = static_cast<float>(temp);  // safe scaling
              }

      - title: "Dir 0.3.2 - A Function Call Shall Not Violate the Function’s Preconditions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Calls to library or user-defined functions must respect their implicit or explicit preconditions.
        impact: |
          Enforcing precondition checks prevents crashes, data corruption, and non-deterministic behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cmath>
              float f(float a) {
                  return fmodf(a, 0.0f);      // violation: divisor must be non-zero
              }
              
              #include <vector>
              int32_t b2() {
                  std::vector<int32_t> v;    
                  return v.front();           // violation: v is empty
              }
            compliant: |
              #include <cmath>
              float f_checked(float a, float b) {
                  if (b == 0.0f) {
                      return 0.0f;            // handle zero divisor
                  }
                  return fmodf(a, b);        // compliant
              }
              
              #include <vector>
              int32_t b2_checked(const std::vector<int32_t>& v) {
                  if (v.empty()) {
                      return -1;             // handle empty case
                  }
                  return v.front();         // compliant
              }
 

  - name: "4.4. General Principles"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 4.1.1 - C++17 Standard Conformance and No Language Extensions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A conforming program shall be well-formed according to C++17 syntax rules,
          diagnosable semantic rules, and the one-definition rule as specified by
          ISO/IEC 14882:2017. Only language and library features defined in C++17
          are permitted; compiler-specific extensions or non-standard constructs are forbidden.
        impact: |
          Enforcing strict C++17 conformance prevents unpredictable behavior,
          improves portability, and ensures reliable static analysis.
        code_examples:
          # C++ examples
          - non_compliant: |
              #warning "declaring an interrupt handler"
              __interrupt void handler();   // uses compiler-specific extension
            compliant: |
              void handler();               // standard C++17 declaration

      - title: "Rule 4.1.2 - Deprecated Features Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Features marked as deprecated in Annex D of the C++17 Standard
          (ISO/IEC 14882:2017) must not be used.
        impact: |
          Prevents reliance on obsolete language and library constructs,
          ensuring forward compatibility with future standard versions.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <codecvt>           // deprecated in C++17
              
              void foo() throw();         // dynamic exception specification
            compliant: |
              #include <locale>           // use <locale> instead of <codecvt>
              
              void foo();                 // no exception specification
    
      - title: "Rule 4.1.3 - No Occurrence of Undefined or Critical Unspecified Behaviour"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A program shall not contain any undefined behaviour or critical unspecified behaviour.
          Undefined behaviour can arise from operations such as:
          • Shifting by an amount ≥ width of the operand  
          • Out-of-range conversions or casts  
          Critical unspecified behaviour is when the standard provides no guarantee on the observable result.
        impact: |
          Eliminating undefined or critical unspecified behaviour ensures deterministic,
          safe, and testable code.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              uint32_t u32a = 0xFFFFFFFF;
              uint32_t u32b = 32;
              uint32_t r1 = u32a >> u32b;               // undefined: shift ≥ width
              
              int8_t x = static_cast<int8_t>(128);      // unspecified: 128 out of int8_t range
            compliant: |
              #include <cstdint>
              #include <limits>

              uint32_t u32a = 0xFFFFFFFF;
              uint32_t u32b = 32;
              uint32_t r1 = (u32b < 32U) 
                            ? (u32a >> u32b) 
                            : 0U;  // guard against invalid shift

              int32_t temp = 128;
              int8_t x;
              if (temp >= std::numeric_limits<int8_t>::min() &&
                  temp <= std::numeric_limits<int8_t>::max()) {
                  x = static_cast<int8_t>(temp);
              } else {
                  x = 0;  // handle out-of-range case
              }

      - title: "Rule 4.6.1 - Avoid Unsequenced Memory Operations"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A side effect on a memory location shall not be unsequenced or indeterminately
          sequenced with respect to any other side effect on the same memory location,
          or any value computation using the value of any object in that location.
          All volatile accesses are treated as accessing the same unique memory location.
        impact: |
          Unsequenced or indeterminately sequenced memory operations invoke undefined
          behavior, leading to unpredictable results or data races. Proper sequencing
          guarantees deterministic, safe code evaluation.
        code_examples:
          # C++ examples
          - non_compliant: |
              extern volatile uint16_t v1, v2;
              void f() {
                  v1 = v1 + v2;         // ← unsequenced volatile accesses → UB
              }
            compliant: |
              extern volatile uint16_t v1, v2;
              void f() {
                  uint16_t tmp = v1 + v2;
                  v1 = tmp;             // ← reads and writes are properly sequenced
              }

          - non_compliant: |
              int arr[10];
              int i = 0;
              int x = arr[i] + i++;   // ← unsequenced read and modification of i → UB
            compliant: |
              int arr[10];
              int i = 0;
              int temp = arr[i];
              i++;
              int x = temp + arr[i];  // ← sequenced: read, update, then read again
   
  - name: "4.5. Lexical Conventions"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 5.0.1 - Trigraph‑Like Sequences Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Trigraph-like sequences (e.g., `??=`, `??/`, `??'`, `??(`, `??)`, `??!`, `??<`, `??>`, `??-`)
          were removed in C++17 and must not appear in source code.
        impact: |
          Avoids ambiguous replacements and toolchain inconsistencies by prohibiting sequences
          removed from the C++ standard, ensuring compatibility with modern compilers.
        code_examples:
          # C++ examples
          - non_compliant: |
              const char* msg = "Date format is ??-??-??";  // contains multiple trigraphs
            compliant: |
              const char* msg = "Date format is ?-?-?";     // uses plain question marks

      - title: "Rule 5.7.1 - The character sequence /* shall not be used within a C‑style comment"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          C-style comments (`/* … */`) must not contain the sequence `/*` inside them.
        impact: |
          Nested comment delimiters can cause compilers to misinterpret or ignore parts of
          the code, leading to hidden defects and portability issues.
        code_examples:
          # C++ examples
          - non_compliant: |
              /* Begin comment
               * Perform_Critical_Safety_Function();
               /* <-- nested comment start, violation
              */
            compliant: |
              /* Begin comment
               * Perform_Critical_Safety_Function();
               // Use '//' for inner notes, not '/*'
              */
    
      - title: "Dir 5.7.2 - Sections of Code Shall Not Be Commented Out"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Code comments (`//`, `/* … */`) must not be used to “comment out” 
          sections of code or to record history of changes. The use of `#if 0` 
          for disabling code is also considered commenting out. Comments should 
          only explain code intent, not hide or disable code fragments.
        impact: |
          Commenting out code can mask defects, confuse reviewers, and lead to 
          stale or unreachable functionality. Maintaining only active code 
          ensures clarity, testability, and prevents accumulation of dead code.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Bug 42 – this call used to be:
              //   calculate(x, y + 1);
              calculate(x, y - 1);
              enum E {
              #if 0
                  F,    // ← commented‑out enumerator
              #else
                  E_1
              #endif
              };
            compliant: |
              struct MyMutex {
                  void lock();
                  void unlock();
              };
        
              // Use RAII for locking instead of commenting out code:
              void f(Data &d, MyMutex &m) {
                  std::scoped_lock lock{m};  // acquires and releases automatically
                  doSomething(d);
              }
   
      - title: "Rule 5.7.3 - Line‑Splicing Shall Not Be Used in // Comments"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A line-splicing backslash (`\`) immediately followed by a newline shall not appear
          inside a `//` single-line comment.
        impact: |
          Line-splicing in comments can hide code or change program logic without notice,
          leading to accidental omissions and hard-to-detect bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f(bool b) {
                  uint16_t x = 0u; // comment \
                  if (b) {         // ← this ‘if’ is treated as part of the comment
                      ++x;
                  }
              }
            compliant: |
              void f(bool b) {
                  uint16_t x = 0u; // proper comment, no splice
                  if (b) {         // clearly code, not part of the comment
                      ++x;
                  }
              }

      - title: "Rule 5.10.1a - Reserved Identifiers Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          User-defined identifiers shall not collide with any names reserved by the
          C++ Standard (library names, implementation-defined identifiers, reserved macros).
        impact: |
          Prevents undefined or implementation-defined behavior due to name collisions
          with the standard or compiler internals.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <vector>

              void vector() {           // violation: name collides with standard type
                  // …
              }
            compliant: |
              #include <vector>

              void myVector() {         // compliant: no collision
                  // …
              }

      - title: "Rule 5.10.1b - Global Identifiers Shall Not Begin With Underscore"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any identifier with namespace or global scope shall not begin with an underscore.
        impact: |
          Avoids collisions with implementation-reserved names and improves readability.
        code_examples:
          # C++ examples
          - non_compliant: |
              int _counter = 0;        // violation: global name starts with underscore
            compliant: |
              int counter = 0;         // compliant

      - title: "Rule 5.13.1 - Within Character Literals and Non‑Raw‑String Literals, '\\' Shall Only Be Used to Form a Defined Escape Sequence or Universal Character Name"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Inside character or non-raw string literals, the backslash (`\`) must only introduce one of
          the standard escape sequences (`\n`, `\t`, `\\`, `\'`, `\"`, `\xNN`, `\uNNNN`, etc.)
          or a universal character name.
        impact: |
          Restricts literals to defined escapes, ensuring consistent and predictable string contents.
        code_examples:
          # C++ examples
          - non_compliant: |
              void fn() {
                  const char *a = "\k";        // '\k' is not a valid escape
              }
            compliant: |
              void fn() {
                  const char *b = "\b\u00E9";  // '\b' and '\u00E9' are valid escapes
              }

      - title: "Rule 5.13.2 - Octal Escape Sequences, Hexadecimal Escape Sequences and Universal Character Names Shall Be Terminated"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every octal escape sequence (`\nnn`), hexadecimal escape sequence (`\xnn…`), or universal
          character name (`\unnnn` / `\Unnnnnnnn`) in a character or string literal must be terminated
          by either the start of another escape/universal sequence or the end of the literal.
        impact: |
          Unterminated escape sequences can be merged with following characters,
          producing unintended values or hiding code. Enforcing termination
          ensures literals contain exactly the intended characters.
        code_examples:
          # C++ examples
          - non_compliant: |
              const char *s1 = "\1234";      // '\123' not terminated
            compliant: |
              const char *s1 = "\123" "4";   // terminated by end of literal

          - non_compliant: |
              const char *s2 = "\x41g";      // '\x41' not terminated
            compliant: |
              const char *s2 = "\x41" "g";   // terminated by end of literal

          - non_compliant: |
              const char *s3 = "\u001F600";  // '\u001F' not terminated
            compliant: |
              const char *s3 = "\U0001F600"; // terminated by end of literal


      - title: "Rule 5.13.3 - Octal Constants Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any integer literal starting with a leading zero (other than the single digit `0`)
          is treated as an octal constant, which may differ from the intended decimal value.
          Octal constants shall not be used.
        impact: |
          Misleading octal notation can cause incorrect values, hidden bugs, and reduced readability.
          Enforcing decimal literals ensures the code behaves as expected.
        code_examples:
          # C++ examples
          - non_compliant: |
              int a = 052;   // Octal 052 is decimal 42, not 52
              int b = 071;   // Octal 071 is decimal 57, not 71
            compliant: |
              int a = 52;    // Decimal 52
              int b = 71;    // Decimal 71

      - title: "Rule 5.13.4 - Unsigned Integer Literals Shall Be Appropriately Suffixed"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any integer literal whose value requires an unsigned type must include an
          explicit unsigned suffix (`U` or `u`).
        impact: |
          Explicit suffixes ensure the literal has the intended unsigned type, avoiding
          signed/unsigned mismatches and platform-dependent behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              
              void example() {
                  auto y = 0x8000;    // non-compliant: missing unsigned suffix
              }
            compliant: |
              #include <cstdint>
              
              void example() {
                  auto y = 0x8000u;   // compliant: explicit unsigned suffix
              }

      - title: "Rule 5.13.5 - The Lowercase Form of L Shall Not Be Used as the First Character in a Literal Suffix"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When specifying a `long` or `long long` integer literal suffix, the uppercase `L`
          must be used as the first character. Using lowercase `l` as the first suffix
          character is prohibited.
        impact: |
          Ambiguity between `l` and the digit `1` can lead to misreading of literals,
          causing maintenance errors and potential value mismatches. Enforcing uppercase `L`
          ensures clarity and consistency.
        code_examples:
          # C++ examples
          - non_compliant: |
              int64_t b = 0l;      // violation: lowercase 'l'
              uint64_t d = 1llu;   // violation: lowercase 'l'
              long long h = 3ll;   // violation: lowercase 'l'
            compliant: |
              int64_t a = 0L;      // compliant: uppercase 'L'
              uint64_t c = 1LLU;   // compliant: uppercase 'L'
              long long g = 3LL;   // compliant: uppercase 'L'

      - title: "Rule 5.13.6 - An Integer‑Literal of Type long long Shall Not Use a Single L or l in Any Suffix"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          For both signed and unsigned `long long` integer literals, a single `L` or `l`
          suffix is prohibited. The suffix must consist of `LL` (or `ULL`) to unambiguously
          denote a `long long` literal.
        impact: |
          Using a single `L` can be misinterpreted as `long` or `unsigned long` depending
          on the platform’s integer sizes. Requiring `LL` ensures consistent interpretation
          as `long long`, improving portability and preventing subtle bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              auto k1 = 12345678998L;      // Single 'L' → ambiguous
              auto k2 = 12345678998l;      // Single 'l' → ambiguous
              auto k4 = 0xFEEDDEADBEEFL;   // Hex literal with single 'L'
            compliant: |
              auto k3 = 12345678998LL;     // Explicit 'LL' suffix
              auto k5 = 0xFEEDDEADBEEFLL;  // Explicit hex long long

      - title: "Rule 5.13.7 - String Literals with Different Encoding Prefixes Shall Not Be Concatenated"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          String literals with differing encoding prefixes (none, L, u8, u, U) must not be placed
          adjacent for implicit concatenation. An empty prefix is considered different from any
          non‑empty prefix, even if the literal contents are identical.
        impact: |
          Concatenating literals of different encodings is ill‑formed or implementation‑defined,
          causing compiler errors or unpredictable behavior. Disallowing such concatenation
          ensures consistent and portable string handling.
        code_examples:
          # C++ examples
          - non_compliant: |
              const char *s2 = "Hello " L"World";      // empty + wide prefix
              const wchar_t *s3 = L"Hello " u8"World"; // wide + UTF‑8 prefix
            compliant: |
              const char *s0 = "Hello " "World";       // both have no prefix
              const char *s4 = u8"Hello " u8"World";   // both have u8 prefix


  - name: "4.6. Basic Concepts"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 6.0.1a - Block‑Scope Function Declarations Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A function shall not be declared at block scope.
        impact: |
          Block-scope function declarations can be mistaken for object definitions,
          reducing readability and leading to parsing ambiguities.
        code_examples:
          # C++ examples
          - non_compliant: |
              void g() {
                  void f2();   // violation: function declared inside g()
                  f2();        // ambiguous call
              }
            compliant: |
              void f2();     // declare at namespace or class scope
              void g() {
                  f2();        // call only
              }

      - title: "Rule 6.0.1b - Block‑Scope Object Declarations Shall Not Use Redundant Parentheses"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Block‑scope objects shall not be declared using parentheses that
          make them syntactically look like functions (e.g. `A a();`).  
          Use braces or no parentheses for value initialization.
        impact: |
          Parenthesized declarations can be misinterpreted as function declarations,
          leading to dead code or miscompiled constructs. Using braces `{}` or
          direct initialization ensures the intent is clear.
        code_examples:
          # C++ examples
          - non_compliant: |
              void g() {
                  A a();     // violation: looks like a function, not an object
              }
            compliant: |
              void g() {
                  A a;       // direct default initialization
                  A b{};     // brace initialization
              }

      - title: "Rule 6.0.2 - When an Array with External Linkage Is Declared, Its Size Shall Be Explicitly Specified"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Non-defining declarations of arrays with external linkage must include an explicit size.
        impact: |
          Explicit array sizes enable compile-time bounds analysis, ensure consistency
          between declarations and definitions, and prevent linker or runtime errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              extern int32_t array2[];        // violation: size not specified
            compliant: |
              extern int32_t array1[10];      // compliant: explicit size
              int32_t array3[] = {0, 10, 15};  // definition infers size from initializer
              extern int32_t array4[42];      // compliant: explicit size on extern declaration

      - title: "Rule 6.0.3 - Only main, namespace and extern \"C\" Declarations Allowed in Global Namespace"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The only entities that may be declared at global namespace scope are:
          • The function `main`.  
          • Namespace definitions or declarations (`namespace X { … }`).  
          • `extern "C"` declarations.  
          All other global declarations are prohibited.
        impact: |
          Restricting global declarations avoids namespace pollution, ODR violations,
          and lookup confusion.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Global variable (violation)
              int globalVar;
              
              // Global function (violation)
              void myFunc();
              
              // Using-directive (violation)
              using namespace std;
              
              // Inline namespace (violation)
              inline namespace v1 {};
            compliant: |
              int main() {}                    // allowed
              namespace Foo { void f(); }      // allowed
              extern "C" void cfunc();         // allowed

      - title: "Rule 6.0.4 - The Identifier main Shall Not Be Used for a Function Other Than the Global Function main"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The identifier `main` must only denote the global program entry point.
          Defining any other function named `main` (in a namespace, class, or block scope)
          is prohibited and may lead to ambiguous entry points or linkage conflicts.
        impact: |
          Restricting `main` to the global function ensures predictable program start‑up,
          avoids violation of language rules, and prevents subtle startup or linkage errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              namespace {
                  int main() {    // violation: main in anonymous namespace
                      return 0;
                  }
              }
              namespace NS {
                  int main() {    // violation: main in named namespace
                      return 0;
                  }
              }
            compliant: |
              int main() {        // only global function main
                  return 0;
              }

      - title: "Rule 4.6.2 - One‑Definition Rule"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Types, templates, inline functions, and objects defined in multiple translation
          units must have identical definitions.
        impact: |
          Inconsistent definitions across translation units can cause data corruption,
          erratic behavior, or crashes.
        code_examples:
          # C++ examples
          - non_compliant: |
              // file1.cpp
              struct S { int x; int y; };
              
              // file2.cpp
              struct S { int y; int x; };   // violation: member order differs
            compliant: |
              // file1.cpp & file2.cpp
              struct S { 
                  int x; 
                  int y; 
              };                           // Identical definition in every translation unit

      - title: "Rule 6.2.1a - Each Program Entity Shall Have Exactly One Definition"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Each program entity shall have exactly one definition in the program.
        impact: |
          Ensures consistent linkage and predictable behavior at link and run time.
        code_examples:
          # C++ examples
          - non_compliant: |
              // a.hpp
              extern int g;

              // a.cpp
              #include "a.hpp"
              // no definition of g here or in any other TU  // violation
            compliant: |
              // a.hpp
              extern int g;

              // a.cpp
              #include "a.hpp"
              int g = 0;  // single, well-defined definition

      - title: "Rule 6.2.1b - A Non-inline Entity Shall Not Be Defined in More Than One Translation Unit"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A non-inline entity shall not be defined in more than one translation unit.
        impact: |
          Prevents multiple definition link errors and ODR violations.
        code_examples:
          # C++ examples
          - non_compliant: |
              // file1.cpp
              int g = 0;

              // file2.cpp
              int g = 0;  // violation: second non-inline definition
            compliant: |
              // file1.cpp
              int g = 0;

              // file2.cpp
              extern int g;  // reference only, no second definition

      - title: "Rule 6.2.1c - Inline Definitions Shall Be Identical in Every Translation Unit"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Inline definitions shall be identical in every translation unit.
        impact: |
          Guarantees a single, consistent inline definition across the program.
        code_examples:
          # C++ examples
          - non_compliant: |
              // f1.hpp
              inline int f() { return 1; }

              // f2.hpp
              inline int f() { return 2; }  // violation: not identical
            compliant: |
              // f1.hpp
              inline int f() { return 1; }

              // f2.hpp
              inline int f() { return 1; }  // identical definition


      - title: "Rule 6.2.2 - All Declarations of a Variable or Function Shall Have the Same Type"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every declaration of a variable or function that refers to the same entity must specify the identical type.
          This includes:
          • Arrays declared with unknown bound vs. known bound (must match element type and size).  
          • Pointers to incomplete vs. complete types (must use the same pointed‑to type).  
          • Functions declared with `[[noreturn]]` must consistently include that attribute.  
        impact: |
          Mismatched declarations across translation units result in undefined behavior,
          causing subtle bugs, incorrect linkage, or runtime failures.
          Ensuring consistent types for all declarations maintains ODR compliance and type safety.
        code_examples:
          # C++ examples
          - non_compliant: |
              // file1.cpp
              extern int arr[];           // array of unknown bound

              // file2.cpp
              extern int arr[10];         // array with bound → type mismatch

              // header.h
              [[noreturn]] void f();      // uses noreturn

              // file.cpp
              void f();                   // missing noreturn attribute → mismatch
            compliant: |
              // file1.cpp & file2.cpp
              extern int arr[10];         // both declarations specify the same bound

              // header.h & file.cpp
              [[noreturn]] void f();      // both declarations include [[noreturn]]

      - title: "Rule 6.2.3 - The Source Code Used to Implement an Entity Shall Appear Only Once"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The definition (implementation) of any non‑inline entity—be it a variable, function,
          class template, or explicit specialization—must appear in exactly one translation unit.
          Inline entities may be defined in multiple TUs only if each definition is identical.
          Explicit specializations must be placed alongside their primary template or in a single
          TU where they are needed.
        impact: |
          Duplicate definitions violate the one‑definition rule, leading to undefined behavior,
          linker errors, or ODR violations. Ensuring a single implementation per entity guarantees
          consistent linkage and program correctness.
        code_examples:
          # C++ examples
          - non_compliant: |
              // file1.cpp
              int x = 42;               // definition #1

              // file2.cpp
              int x = 42;               // definition #2 → violation

              // header.h
              template<typename T>
              T f(T v) { return v; }    // primary template

              // fileA.cpp
              #include "header.h"
              template<>                 // explicit specialization here
              int f<int>(int v) { return v * 2; }

              // fileB.cpp
              #include "header.h"
              template<>                 // same specialization again → violation
              int f<int>(int v) { return v * 2; }
            compliant: |
              // header.h
              extern int x;             // declaration only

              // file1.cpp
              #include "header.h"
              int x = 42;               // single definition

              // header.h
              template<typename T>
              T f(T v) { return v; }    // primary template

              // fileA.cpp
              #include "header.h"
              template<>                 // explicit specialization only once
              int f<int>(int v) { return v * 2; }

      - title: "Rule 6.2.4 - A Header File Shall Not Contain Definitions of Functions or Objects That Are Non‑Inline and Have External Linkage"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Header files shall not contain definitions of non-inline functions or objects
          that have external linkage.
        impact: |
          Defining non-inline functions or variables in headers leads to duplicate symbols
          across translation units, breaking linkage and risking runtime failures.
        code_examples:
          # C++ examples
          - non_compliant: |
              // header.h
              int  globalVar = 42;           // violation: definition in header
              void helper() { /*...*/ }       // violation: non-inline function defined in header
              struct S {
                  static int value;
              };
              int S::value = 0;               // violation: static member definition in header
            compliant: |
              // header.h
              extern int  globalVar;          // declaration only
              inline void helper() { /*...*/ } // compliant: inline function
              struct S {
                  static inline int value = 0; // compliant: inline static member
              };

      - title: "Rule 6.4.1 - A Variable Declared in an Inner Scope Shall Not Hide a Variable Declared in an Outer Scope"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A variable declared in an inner scope shall not use the same name as a variable
          declared in an outer scope.
        impact: |
          Name hiding can confuse readers and maintainers, introduce subtle bugs, and make
          debugging more difficult.
        code_examples:
          # C++ examples
          - non_compliant: |
              int counter = 0;
              void increment() {
                  int counter = 1;    // hides outer 'counter'
                  ++counter;
              }
            compliant: |
              int counter = 0;
              void increment() {
                  int localCounter = 1;  // no hiding
                  ++localCounter;
              }

      - title: "Rule 6.4.2 - Derived Classes Shall Not Conceal Inherited Functions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A derived class shall not declare a member (function or variable) with the same name
          as a base-class function unless one of the following holds:
          • The base class is privately inherited.  
          • The base function is virtual and the derived class overrides it.  
          • The base function is reintroduced via a `using`-declaration.  
          • The derived class provides a copy-assignment or move-assignment operator.  
        impact: |
          Concealing inherited functions breaks polymorphism and can lead to unexpected calls
          or name lookup errors. Enforcing this rule preserves correct binding of base-class
          functionality and predictable behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Base {
                  void f(int);
              };
              struct Derived : public Base {
                  void f();           // hides Base::f(int)
              };
            compliant: |
              struct Base {
                  void f(int);
              };
              struct Derived : public Base {
                  using Base::f;      // reintroduce the overload
                  void f();           // overload alongside Base::f(int)
              };

      - title: "Rule 6.4.3 - A Name That Is Present in a Dependent Base Shall Not Be Resolved by Unqualified Lookup"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a class template with a dependent base, any name present in the base shall
          not be looked up unqualified in the derived class.
        impact: |
          Unqualified lookup can bind to the wrong entity (e.g., a global function),
          breaking intended behavior and causing subtle bugs. Enforcing qualified lookup
          preserves correct name resolution in templates.
        code_examples:
          # C++ examples
          - non_compliant: |
              template<typename T>
              struct Base {
                  void f() {}
              };
              template<typename U>
              struct Derived : Base<U> {
                  void g() {
                      f();          // violation: unqualified lookup ignores Base<U>::f
                  }
              };
            compliant: |
              template<typename T>
              struct Base {
                  void f() {}
              };
              template<typename U>
              struct Derived : Base<U> {
                  void g() {
                      this->f();   // qualified lookup correctly resolves Base<U>::f
                  }
              };

      - title: "Rule 6.5.1 - A Function or Object with External Linkage Shall Be Introduced in a Header File"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All functions and objects with external linkage (namespace scope) must have a corresponding
          declaration (“introduction”) in a header file. The header containing the declaration shall be
          included by every translation unit that defines or uses the entity.  
          This rule does not apply to the `main` function.
        impact: |
          Placing external‑linkage declarations in headers ensures consistency between declarations
          and definitions, prevents one‑definition rule violations, and makes APIs discoverable
          across translation units, reducing linkage and build errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              // impl.cpp
              int compute() { return 0; }   // defined without any header declaration

              // user.cpp
              int x = compute();            // usage without including a header
            compliant: |
              // api.h
              int compute();                // declaration in header

              // impl.cpp
              #include "api.h"
              int compute() { return 0; }   // definition matches header

              // user.cpp
              #include "api.h"
              int x = compute();            // usage via header declaration
              
      - title: "Rule 6.5.2 - Internal Linkage Shall Be Specified Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An entity intended for internal linkage shall be declared in an anonymous namespace,
          without using `extern`, and without the `static` keyword.  
          Entities declared `constexpr` or `const` are exempt.
        impact: |
          Using `static` or `extern` for internal‑linkage entities can confuse their intended
          visibility, hamper code isolation, or cause ODR issues. Placing them in an anonymous
          namespace ensures clear, unambiguous internal linkage.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Attempts to give internal linkage via 'static'
              static void helper() { /*…*/ }   

              // Extern inside anonymous namespace (no effect on linkage)
              namespace {
                  extern int internalVar;  
              }
            compliant: |
              namespace {  
                  void helper() { /*…*/ }   // internal linkage via anon namespace
                  int internalVar;          // internal linkage
              }              
              
      - title: "Rule 6.7.1 - Local Variables Shall Not Have Static Storage Duration"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Local variables declared inside functions shall not be given static storage duration
          (i.e. must not use the `static` keyword).  
          Variables declared `constexpr` or `const` are exempt.
        impact: |
          Static local variables introduce hidden state and temporal coupling, which:
          • Hinders testability and maintainability  
          • Risks data races in multithreaded code  
          • Leads to unpredictable behavior during object lifetime and destruction  
          Enforcing automatic storage duration improves modularity and clarity.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  static int counter = 0;  // violation: persistent local state
                  ++counter;
              }
            compliant: |
              void f() {
                  int counter = 0;         // automatic storage, reset each call
                  ++counter;
              }

      - title: "Rule 6.7.2 - Global Variables Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Namespace-scope variables and class static data members (global variables) shall not be used.
          Exceptions are `constexpr` variables or `const` variables with static initialization.
        impact: |
          Global variables introduce hidden shared state, reduce modularity and testability,
          can cause initialization-order fiascos, and risk data races in concurrent code.
          Eliminating globals improves encapsulation, predictability, and maintainability.
        code_examples:
          # C++ examples
          - non_compliant: |
              int globalCounter = 0;    // global variable

              void increment() {
                  ++globalCounter;      // uses hidden shared state
              }
            compliant: |
              constexpr int MAX_COUNT = 100;            // allowed: constexpr global
              static const int DEFAULT_TIMEOUT = 30;    // allowed: const with static init

              void process(int value) {
                  int counter = (value < MAX_COUNT) ? value : MAX_COUNT;
                  // …
              }             

      - title: "Rule 6.8.1 - An Object Shall Not Be Accessed Outside of Its Lifetime"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          No access (read or write) shall be performed on an object outside the interval
          from the start of its lifetime to the end of its lifetime. Accessing before
          initialization, after destruction, or on inactive union members is prohibited.
        impact: |
          Accessing memory outside an object’s lifetime leads to undefined behavior,
          crashes, security vulnerabilities or data corruption. Enforcing this rule
          ensures memory safety and predictable program semantics.
        code_examples:
          # C++ examples
          - non_compliant: |
              int* getPtr() {
                  int x = 42;
                  return &x;      // returns address of a local
              }
              void f() {
                  int* p = getPtr();
                  *p = 10;         // ← violation: x’s lifetime has ended
              }
            compliant: |
              void f() {
                  int x = 42;
                  int* p = &x;     // p points to x within its lifetime
                  *p = 10;         // safe access
              }
          - non_compliant: |
              struct S { int i; };
              void g() {
                  alignas(S) char buf[sizeof(S)];
                  S* p = new(buf) S{5};
                  p->~S();         // destroys object
                  int v = p->i;    // ← violation: access after destruction
              }
            compliant: |
              struct S { int i; };
              void g() {
                  S obj{5};
                  int v = obj.i;   // access within lifetime
              }
              
      - title: "Rule 6.8.2 - A Function Shall Not Return a Reference or Pointer to a Local Variable with Automatic Storage Duration"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Functions shall not return a reference or pointer to a local object with automatic storage duration.
        impact: |
          Returning dangling references or pointers leads to undefined behavior, crashes, and memory corruption.
          Enforcing this rule prevents use-after-free errors and ensures returned values remain valid.
        code_examples:
          # C++ examples
          - non_compliant: |
              int* getPtr() {
                  int x = 10;
                  return &x;                // violation: returns address of local
              }
            compliant: |
              int getVal() {
                  int x = 10;
                  return x;                 // compliant: returns by value
              }
          - non_compliant: |
              #include <functional>

              std::function<int&()> makeGetter(int a) {
                  return [&]() -> int& { return a; };  // violation: returns reference to local copy
              }
            compliant: |
              #include <functional>

              std::function<int()> makeGetter(int a) {
                  return [a]() { return a; };         // compliant: returns by value
              }

      - title: "Rule 6.8.3 - An Assignment Operator Shall Not Assign the Address of an Object with Automatic Storage Duration to an Object with a Greater Lifetime"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a user-defined assignment operator (`operator=`), the right-hand side shall not
          be the address of a local (automatic) object.
        impact: |
          Dangling pointers lead to undefined behavior, crashes, and corrupted data.
          Preventing such assignments ensures that stored addresses remain valid for the
          lifetime of the pointed-to objects.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Node {
                  int *ptr;
                  Node& operator=(int value) {
                      int temp = value;
                      ptr = &temp;         // violation: assigns address of local
                      return *this;
                  }
              };
            compliant: |
              struct Node {
                  int *ptr;
                  Node& operator=(int value) {
                      ptr = new int(value); // compliant: allocate for longer lifetime
                      return *this;
                  }
              };

      - title: "Rule 6.8.4 - Member Functions Returning References to Their Object Shall Be Ref‑Qualified Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any member function returning a reference or pointer to its object (or a subobject)
          shall be qualified so it cannot be called on a temporary.  
          Such functions must be declared with an lvalue-ref-qualifier (`&` or `const &`) 
          if they return a subobject of `*this`.
        impact: |
          Without proper ref-qualification, calls on temporaries bind to destroyed objects,
          causing undefined behavior. Enforcing this rule ensures that only live objects 
          may expose their internal references or pointers.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A {
                  int32_t a;
                  int32_t &getMe() { return a; }     // callable on temporaries → dangling
              };
              A createA();
              A &dangling = createA().getMe();       // immediate dangling
            compliant: |
              struct A {
                  int32_t a;
                  int32_t &getMe() & { return a; }     // only callable on lvalues
              };
              A obj;
              A &valid = obj.getMe();               // safe: obj is alive

          - non_compliant: |
              struct B {
                  int32_t a;
                  B &self() { return *this; }         // no & qualifier → callable on temporaries
              };
            compliant: |
              struct B {
                  int32_t a;
                  B &self() & { return *this; }       // only callable on lvalues
              };

      - title: "Rule 6.9.1 - The Same Type Aliases Shall Be Used in All Declarations of the Same Entity"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When an entity (variable or function) is declared multiple times, all declarations
          must use the identical type alias.
        impact: |
          Inconsistent use of type aliases can lead to confusion, maintenance errors,
          and subtle linkage or overload-resolution bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              typedef int32_t INT;
              using Index = int32_t;

              extern INT i;          // alias INT
              extern int32_t i;     // underlying type → violation

              void g(int32_t v);
              void g(Index v);      // mixing aliases → violation
            compliant: |
              typedef int32_t INT;

              extern INT i;          // consistent alias
              extern INT j;          // consistent alias

              void g(INT v);
              void g(INT const v);  // same alias, top-level const allowed

      - title: "Rule 6.9.2 - The Names of the Standard Signed Integer Types and Standard Unsigned Integer Types Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built‑in type names `char`, `short`, `int`, `long`, `signed` and `unsigned`
          (with any cv‑qualification) shall not be used for declaring objects or functions.
          Such names have implementation‑defined widths.  
          Instead, use fixed‑width (e.g. `int32_t`, `uint16_t`) or extended‑width types
          from `<cstdint>`, with `static_assert` to verify size assumptions as needed.

          Exceptions:
          • These names may be used to define a type alias (e.g. `using torque_t = unsigned short;`).  
          • The name `int` may appear only as the parameter type or return type of `main`.  
          • The parameter `argc` of `main` may be typed `int`.
        impact: |
          Relying on implementation‑defined integer sizes can introduce subtle portability
          errors, incorrect overflow behavior, and mismatches in binary interfaces.
          Explicit fixed‑width types ensure consistent behavior across platforms.
        code_examples:
          # C++ examples
          - non_compliant: |
              int counter;           // implementation‑defined width
              unsigned flags;        // implementation‑defined width
              long total;            // implementation‑defined width
            compliant: |
              #include <cstdint>
              static_assert(sizeof(int32_t) == 4, "Require 32‑bit int");
              int32_t counter;       // fixed 32‑bit
              uint8_t flags;         // fixed 8‑bit
              int64_t total;         // fixed 64‑bit


  - name: "4.7. Standard Conversions"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 
    
      - title: "Rule 7.0.1 - There Shall Be No Conversion from Type bool"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All implicit and explicit conversions from `bool` to any other type are prohibited,
          except in these cases:
          1. When using `==` or `!=` to compare two `bool` operands.  
          2. When explicitly casting `bool` to a class type `T` that has a converting constructor
             taking a single `bool` parameter (via `T{true}`, `T(true)`, `static_cast<T>(true)`, etc.).
        impact: |
          Converting `bool` to integral or arithmetic types is often unintended and can mask logic errors.
          For example, confusing `&` (bitwise) with `&&` (logical) on `bool` operands or relying on
          promotion may hide bugs. Disallowing these conversions improves type safety and readability.
        code_examples:
          # C++ examples
          - non_compliant: |
              bool flag = true;
              int x = flag;         // implicit conversion to int
              auto y = +flag;       // unary + promotes to int
              if (flag & other) {   // bitwise-AND on bool (likely error)
                  … 
              }
            compliant: |
              bool flag = true;
              int x = flag ? 1 : 0;           // explicit boolean-to-integer
              bool result = (flag == other); // allowed as equality operator
              struct B { B(bool); };
              B b1{flag};                     // explicit cast to class B via converting ctor

      - title: "Rule 7.0.2 - There Shall Be No Conversion to Type bool"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Conversions from any fundamental type, unscoped enumeration type, or pointer to `bool`
          are prohibited except in these contexts:
          1. In a conditional context: the operand of `if`, `while`, `for`, `do…while`, the first
             operand of `?:`, or the operand of a logical operator (`&&`, `||`, `!`).  
          2. An explicit `static_cast<bool>` when converting a class type that provides an
             `explicit operator bool`.  
          3. Initializing a 1‑bit bit‑field from an integral value.  
        impact: |
          Implicit conversion to `bool` can mask logic errors (e.g. using an integer as a condition
          unintentionally) or hide misuse of pointers, leading to undefined or surprising behavior.
          Requiring explicit comparisons or casts makes boolean intent clear and prevents errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              int x = 5;
              bool b1 = x;           // implicit conversion to bool
              bool b2 = ptr;         // pointer-to-bool conversion
              enum E { A, B };
              bool b3 = A;           // enum-to-bool conversion
            compliant: |
              bool b1 = (x != 0);    // explicit comparison
              bool b2 = (ptr != nullptr);
              enum E { A, B };
              bool b3 = (A == B);
              struct C { explicit operator bool() const; };
              C c;
              bool b4 = static_cast<bool>(c);  // explicit cast allowed
 
      - title: "Rule 7.0.3 - The Numerical Value of a Character Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Character types (`char`, `signed char`, `unsigned char`, `char16_t`, `char32_t`, `wchar_t`)
          are for representing characters, not integers. There shall be no implicit or explicit
          conversion to or from an expression with character category, except when using
          `std::char_traits` functions for character processing.
        impact: |
          Treating characters as numeric values can mask encoding issues, reduce portability,
          and lead to incorrect arithmetic. Using dedicated character-handling utilities
          ensures correct interpretation and safe manipulation.
        code_examples:
          # C++ examples
          - non_compliant: |
              char c = 'A';
              int x = c;               // implicit conversion to integer
              unsigned u = c + 1;      // arithmetic on char value
            compliant: |
              #include <charconv>
              #include <char_traits>
              #include <cctype>
              #include <string>
              
              void processChar(char c) {
                  // convert character to its int_type without numeric arithmetic
                  auto ci = std::char_traits<char>::to_int_type(c);
                  // use standard character utilities
                  if (std::isupper(static_cast<unsigned char>(c))) {
                      std::string s(1, c);
                      // e.g., convert to lowercase with locale-safe function
                      std::string lower;
                      lower += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
                      // further character processing...
                  }
                  // other character handling logic...
              }

      - title: "Rule 7.0.4 - The Operands of Bitwise Operators and Shift Operators Shall Be Appropriate"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The operands of binary bitwise operators (`&`, `|`, `^`, `~`) and shift operators
          (`<<`, `>>`) must meet these conditions:
          • Both operands of bitwise operators and the operand of the complement operator must be of an unsigned type.  
          • For shift operators:
            – The left operand must be unsigned.  
            – The right operand must be either a non-constant expression of unsigned type or a constant expression in the range  
              `[0, sizeof(T)*CHAR_BIT – 1]`, where `T` is the type of the left operand (after promotion).  
          These restrictions also apply to the corresponding compound assignments (e.g., `&=`, `<<=`).

        impact: |
          Bitwise operations on signed types may yield undefined behavior when the sign bit is involved.
          Shifting by a negative count or by a count ≥ width of the type is undefined or implementation-defined.
          Enforcing unsigned operands and valid shift counts prevents data corruption and unpredictable behavior.

        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              int8_t  a = -1;
              uint8_t b = 1;
              auto r1 = a & b;           // violation: 'a' is signed

              unsigned int x = 1;
              int shift = -1;
              auto r2 = x << shift;      // violation: shift is negative

              auto r3 = x << (sizeof(unsigned int) * CHAR_BIT); // violation: shift >= width
            compliant: |
              #include <cstdint>
              uint8_t  a = 5;
              uint8_t  b = 3;
              auto r1 = a & b;           // safe: unsigned operands

              #include <climits>
              unsigned int x = 1;
              unsigned int y = 2;
              auto r2 = x << y;          // safe: valid shift count

              constexpr unsigned int maxShift = sizeof(unsigned int) * CHAR_BIT - 1;
              auto r3 = x << maxShift;   // safe: constant within range

      - title: "Rule 7.0.5 - Integral Promotion and Usual Arithmetic Conversions Shall Not Change Signedness or Type Category"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          For any expression of numeric type (including sub‑expressions and within `#if`/`#elif`),
          integral promotions and the usual arithmetic conversions must not alter the signedness
          (signed ↔ unsigned) or the type category (integral ↔ floating) of any operand.
        impact: |
          Changing signedness or converting between integral and floating types can introduce
          overflows, precision loss, or sign‑flip bugs, potentially causing undefined behavior
          or logic errors. Enforcing this rule preserves value correctness and predictability.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              uint32_t a = 1u;
              int32_t  b = 2;
              auto r1 = a + b;            // `a` promoted to signed → signedness changed

              int16_t x = 10;
              float   y = 1.5f;
              auto r2 = x * y;            // `x` converted to float → type category changed
            compliant: |
              #include <cstdint>
              uint32_t a = 1u;
              uint32_t b = 2u;
              auto r1 = a + b;            // both operands remain unsigned integral

              int16_t x = 10;
              int16_t y = 5;
              auto r2 = x * y;            // both operands remain integral

      - title: "Rule 7.0.6 - Assignment Between Numeric Types Shall Be Appropriate"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All assignments where the source and target are numeric types must not:
            • change the type category (integral ↔ floating) or the signedness (signed ↔ unsigned);  
            • narrow the value by assigning from a wider type to a narrower type, unless the source is a constant integer expression and the target (numeric type or bit‑field) can represent its value.
            
          Exception: Passing a single numeric argument to a constructor whose parameter type is exactly the source type is permitted without an explicit conversion.
        impact: |
          Implicit arithmetic conversions on assignment can introduce silent narrowing, loss of precision,
          sign‑flips, or undefined behavior. Restricting these conversions ensures data integrity,
          avoids overflow and preserves predictable semantics.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              uint16_t u16 = 500;
              int8_t  i8 = u16;          // narrowing + unsigned→signed → UB or data loss

              float f = 3.14f;
              int   i = f;               // float→int narrowing → loss of fractional part

              void g(int);
              g(2.7);                    // implicit conversion float→int
            compliant: |
              #include <cstdint>
              uint16_t u16 = 500;
              uint16_t u16b = u16;       // same type assignment

              float f = 3.14f;
              int   i = static_cast<int>(f); // explicit conversion

              void g(int);
              g(2);                      // exact match to parameter type

      - title: "Rule 7.11.1 - nullptr Shall Be the Only Form of the Null‑Pointer‑Constant"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The only valid null‑pointer constant in C++ is `nullptr`.  
          Any use of the integer literal `0` or the macro `NULL` to denote a null pointer
          is prohibited.
        impact: |
          Using `0` or `NULL` for null pointers can lead to ambiguous overload resolution,
          unintended conversions, and reduced type safety.  
          Enforcing `nullptr` ensures clear intent and correct overload selection.
        code_examples:
          # C++ examples
          - non_compliant: |
              int* p1 = 0;         // integer literal zero
              char* p2 = NULL;     // macro NULL

              void f(int*);
              void f(bool);
              f(NULL);            // ambiguous: could call f(int*) or f(bool)
            compliant: |
              int* p1 = nullptr;
              char* p2 = nullptr;

              void f(int*);
              void f(bool);
              f(nullptr);         // unambiguous null‑pointer

      - title: "Rule 7.11.2 - An Array Passed as a Function Argument Shall Not Decay to a Pointer"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When passing an array to a function, it must not decay to a plain pointer and lose its size information.
          Functions shall declare array parameters in one of these forms:
          1. A fixed‑size array parameter (e.g. `void f(int32_t (&p)[10])`).  
          2. A template parameter capturing the array dimension (e.g. `template<size_t N> void f(int32_t (&p)[N])`).  
          3. A span or view type (e.g. `std::span<int32_t>`, `std::string_view`).  
          4. An `std::initializer_list<T>` when only list initialization is needed.  

          Exception: Passing a string literal to a function expecting a `char const*` is permitted,  
          since the literal is null‑terminated and its length is known at compile time.
        impact: |
          Decay to pointer loses compile‑time bounds information, making out‑of‑bounds errors harder to detect,
          preventing static analysis of array size, and reducing code safety. Preserving array dimensions
          enhances readability, enables bounds checking, and prevents subtle bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f1(int32_t *p);
              int32_t a[10];
              f1(a);    // array decays to pointer → dimension lost
            compliant: |
              void f2(int32_t (&p)[10]);
              int32_t a[10];
              f2(a);    // array passed by reference → size preserved
          - non_compliant: |
              #include <cstdint>
              void process(size_t n, int32_t *p);
              int32_t buf[5];
              process(5, buf);  // decays to pointer
            compliant: |
              #include <span>
              void process(std::span<int32_t> p);
              int32_t buf[5];
              process(buf);     // implicit conversion to std::span preserves size

      - title: "Rule 7.11.3 - A Conversion from Function Type to Pointer‑to‑Function Type Shall Only Occur in Appropriate Contexts"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Conversions from a function type to a pointer-to-function type shall only occur:
          1. Via a `static_cast<Ret(*)(Args…)>(…)` to explicitly obtain a function pointer.  
          2. In an assignment where the target is already a pointer-to-function type.
        impact: |
          Implicit decay of a function to a pointer in contexts like boolean tests or auto assignments
          can be ambiguous or unintended. Forcing explicit casts or pointer-type targets ensures
          clarity and prevents hidden conversions.
        code_examples:
          # C++ examples
          - non_compliant: |
              extern int f();
              
              if (f) {            // violation: implicit conversion of f to bool
                  /*…*/
              }
              
              auto p = f;         // violation: auto deduced as function pointer by decay
            compliant: |
              extern int f();
              
              // Explicit cast to pointer-to-function type
              int (*p)() = static_cast<int(*)()>(f);
              if (p != nullptr) {
                  /*…*/
              }
              
              // Assignment to pointer-to-function target
              int (*q)() = f;     // compliant: decay in assignment to pointer type

    

  - name: "4.8. Expressions"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 8.0.1 - Parentheses Shall Be Used to Make the Meaning of an Expression Appropriately Explicit"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When the intended evaluation order of an expression is not evident from the
          default operator precedence and associativity, parentheses shall be added to
          make the intended grouping explicit.
        impact: |
          Omitting necessary parentheses can lead to subtle bugs when operator precedence
          or associativity differs from developer expectations—especially in conditional
          expressions, shifts, logical combinations, and preprocessor directives.
        code_examples:
          # C++ examples
          - non_compliant: |
              int x = a << b + c;            // '<<' has lower precedence than '+'
            compliant: |
              int x = a << (b + c);          // parentheses show intended grouping

          - non_compliant: |
              #if defined(A) && defined(B) || defined(C)
            compliant: |
              #if defined(A) && (defined(B) || defined(C))

      - title: "Rule 8.1.1 - A Non‑Transient Lambda Shall Not Implicitly Capture this"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A non-transient lambda shall not implicitly capture `this`.
        impact: |
          Dangling `this` pointers cause undefined behavior when the lambda outlives its object.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A {
                  int16_t val;
                  void f() {
                      auto L1 = [=]() { return val; };  // implicitly captures `this`
                      auto L2 = [&]() { return val; };  // implicitly captures `this`
                  }
              };
            compliant: |
              struct A {
                  int16_t val;
                  void f() {
                      auto L3 = [this]() { return val; };                // explicit capture of `this`
                      auto L4 = [self = *this]() { return self.val; };   // capture copy of object
                  }
              };

      - title: "Rule 8.1.2 - Variables Should Be Captured Explicitly in a Non‑Transient Lambda"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a non-transient lambda, every variable accessed from an enclosing scope
          shall be listed explicitly in the capture list.
        impact: |
          Explicit capture promotes clarity about a lambda’s dependencies, prevents
          accidental dangling references or unintended captures, and makes code review
          and maintenance easier.
        code_examples:
          # C++ examples
          - non_compliant: |
              void bar(double val, double min, double max) {
                  auto f2 = [=]() {
                      if (val < min) return (val + min) / 2;
                      if (val > max) return (val + max) / 2;
                      return val;
                  };  // f2 may outlive bar() and captures val, min, max implicitly
              }
          - non_compliant: |
              struct Speedometer {};
              void addLoggers(Speedometer s, std::ostream& os) {
                  s.addObserver([&](double speed) { os << speed; });  
                  // implicitly captures os (and s) by reference
              }
            compliant: |
              void bar(double val, double min, double max) {
                  auto f2 = [val, min, max]() {
                      if (val < min) return (val + min) / 2;
                      if (val > max) return (val + max) / 2;
                      return val;
                  };  // explicit capture of all used variables
              }

              struct Speedometer {};
              void addLoggers(Speedometer s, std::ostream& os) {
                  s.addObserver([&os](double speed) { os << speed; });  
                  // explicit capture of os only
                  s.addObserver([](double speed) { std::cout << speed; });  
                  // no capture needed when only using global std::cout
              }

      - title: "Rule 8.2.1 - A Virtual Base Class Shall Only Be Cast to a Derived Class by Means of dynamic_cast"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When downcasting from a polymorphic base class to a derived class, only
          `dynamic_cast<Derived*>(basePtr)` or `dynamic_cast<Derived&>(baseRef)` is permitted.
        impact: |
          Unsafe downcasts can violate type safety, causing crashes or data corruption
          if the object is not of the target type. Enforcing `dynamic_cast` provides
          RTTI-based verification, returning `nullptr` or throwing `std::bad_cast` on failure.
        code_examples:
          # C++ examples
          - non_compliant: |
              class B { virtual ~B() {} };
              class D : public virtual B {};
              
              B* pb = new D;
              D* pd1 = static_cast<D*>(pb);       // violation: unsafe static_cast
              D* pd2 = reinterpret_cast<D*>(pb);  // violation: reinterpret_cast
            compliant: |
              class B { virtual ~B() {} };
              class D : public virtual B {};
              
              B* pb = new D;
              D* pd = dynamic_cast<D*>(pb);       // safe downcast (nullptr if not D)

      - title: "Rule 8.2.2 - C‑style Casts and Functional Notation Casts Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          C-style casts (`(T)expr`) and functional-notation casts (`T(expr)`) are prohibited.
          Use C++ cast operators (`static_cast`, `const_cast`, `reinterpret_cast`, `dynamic_cast`) instead.

          _Exception_: Functional notation with brace-initialization (`T{expr}`) or constructor calls are permitted.
        impact: |
          Unrestricted casts can hide narrowing, remove cv-qualifiers, and introduce
          undefined behavior. Using explicit C++ casts enforces type constraints,
          clarifies developer intent, and aids static analysis.
        code_examples:
          # C++ examples
          - non_compliant: |
              int   i = 42;
              float f = (float)i;        // C-style cast
              int   j = int(3.7);        // functional cast
              void* p = (void*)&i;       // C-style pointer cast
            compliant: |
              int   i = 42;
              float f = static_cast<float>(i);
              int   j = static_cast<int>(3.7);
              void* p = reinterpret_cast<void*>(&i);

              struct S { S(int); };
              S s1(10);                  // constructor call, not a cast
              S s2{10};                  // brace-initialization, allowed

      - title: "Rule 8.2.3 - A Cast Shall Not Remove Any const or volatile Qualification from the Type Accessed Via a Pointer or by Reference"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any cast that discards `const` or `volatile` qualifiers from the pointee or
          referred-to object is prohibited.
        impact: |
          Dropping `const` can allow modification of read-only objects or mask const-correctness.
          Dropping `volatile` can let the compiler optimize away required accesses,
          breaking hardware interactions or concurrency guarantees.
        code_examples:
          # C++ examples
          - non_compliant: |
              const int ci = 42;
              int* p1 = (int*)&ci;                      // violation: cast removes const

              const volatile int cv = 1;
              int* p2 = const_cast<int*>(&cv);          // violation: cast removes const & volatile

              const int& rci = ci;
              int& r2 = const_cast<int&>(rci);         // violation: cast removes const from reference
            compliant: |
              const int ci = 42;
              const int* p1 = &ci;                      // qualifiers preserved

              const volatile int cv = 1;
              const volatile int* p2 = &cv;             // qualifiers preserved

              const int& rci = ci;
              const int& r2 = rci;                      // reference preserves const

      - title: "Rule 8.2.4 - Casts Shall Not Be Performed Between a Pointer to Function and Any Other Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Conversions or casts between a pointer-to-function type and any other type
          (pointer-to-object, pointer-to-member, pointer-to-incomplete-type, `void*`, etc.)
          are prohibited.  
          Permitted conversions are:
          • Implicit conversion of a function to a function-pointer type (address-of).  
          • Null-pointer conversions (`nullptr`).  
          • Implicit conversion of a captureless lambda to a function pointer.  
          • Function-pointer conversions between compatible pointer types.
        impact: |
          Unsafe casts bypass type safety and can lead to undefined behavior, crashes,
          or memory corruption when invoking functions through improperly typed pointers.
          Enforcing this rule ensures predictable and reliable function dispatch.
        code_examples:
          # C++ examples
          - non_compliant: |
              extern int f();
              // C‑style cast to void*
              void *pv = (void*)f;                        
              // reinterpret_cast between function and object pointer
              auto pf = reinterpret_cast<void(*)()>(f);  
            compliant: |
              extern int f();
              // implicit function-to-pointer conversion
              int (*p1)()    = f;                         
              int (*p2)()    = &f;                        
              // null-pointer conversion
              int (*p3)()    = nullptr;                   
              // lambda-to-function-pointer conversion (captureless)
              auto lam      = +[](int x){ return x; };
              int (*p4)(int) = lam;                       

      - title: "Rule 8.2.5 - reinterpret_cast Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The use of `reinterpret_cast` is prohibited.

          _Exceptions_ (permitted uses of `reinterpret_cast`):
          1. Converting an object pointer to `void*`, `char*`, `unsigned char*` or `std::byte*`  
             (possibly cv-qualified).  
          2. Converting a pointer to an integer type (`std::uintptr_t`) that is guaranteed
             to hold a pointer value.
        impact: |
          Restricting reinterpret_cast to only the two safe forms ensures portability
          and preserves object semantics.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A {}; struct B {};
              A* a = new A;
              B* b = reinterpret_cast<B*>(a);       // violation: unrelated pointer types

              void* p = a;
              int   x = reinterpret_cast<int>(p);    // violation: integer type too small
            compliant: |
              #include <cstddef>
              #include <cstdint>

              void* p = /* … */;
              char*           cp  = reinterpret_cast<char*>(p);            // allowed
              unsigned char*  ucp = reinterpret_cast<unsigned char*>(p);   // allowed
              std::byte*      bp  = reinterpret_cast<std::byte*>(p);       // allowed

              #include <cstdint>
              std::uintptr_t addr = reinterpret_cast<std::uintptr_t>(p);    // allowed

      - title: "Rule 8.2.6 - An Object with Integral, Enumerated, or Pointer to void Type Shall Not Be Cast to a Pointer Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Casting an object of integral type, enumeration type, or a `void*` to any object
          pointer type (other than `void*`) is prohibited.
        impact: |
          Unsafe casts can corrupt memory, violate type safety, or cause crashes when
          dereferencing the resulting pointer. Enforcing this rule prevents invalid
          pointer conversions and preserves program correctness.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct S { int32_t i; };

              void f() {
                  int x = 42;
                  S* s1 = reinterpret_cast<S*>(x);     // violation: integer → pointer
                  
                  void* v = &x;
                  S* s2 = static_cast<S*>(v);          // violation: void* → S*
              }
            compliant: |
              struct S { int32_t i; };

              void f() {
                  S obj{ 42 };
                  S* s1 = &obj;                        // compliant: no cast, direct pointer to S
              }

      - title: "Rule 8.2.7 - A Cast Shall Not Convert a Pointer Type to an Integral Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Converting a pointer-to-object type to any integral type is prohibited.
        impact: |
          Restricting pointer-to-integer casts preserves portability and predictable semantics.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              struct S { };
              S* p = /* … */;
              std::uint32_t x1 = reinterpret_cast<std::uint32_t>(p);  // violation: pointer → uint32_t
              int           x2 = static_cast<int>(p);                 // violation: pointer → int
            compliant: |
              #include <cstdint>
              struct S { };
              S* p = /* … */;
              std::uintptr_t addr = reinterpret_cast<std::uintptr_t>(p);  // allowed: pointer → uintptr_t

      - title: "Rule 8.2.8 - An Object Pointer Type Shall Not Be Cast to an Integral Type Other Than std::uintptr_t or std::intptr_t"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In any cast from an object pointer to an integral type, the type-id shall be
          either `std::uintptr_t` or `std::intptr_t`. Casting to any other integer type is prohibited.
        impact: |
          Using an integer type that cannot hold all pointer values risks value truncation,
          invalid pointer reconstruction, undefined behavior, or crashes. Enforcing
          `std::uintptr_t`/`std::intptr_t` ensures portable, lossless pointer-to-integer casts.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct S { };
              S* p = /*…*/;
              auto x1 = reinterpret_cast<unsigned long>(p);   // violation: unsigned long is not uintptr_t
              auto x2 = static_cast<int>(p);                 // violation: int is not intptr_t
            compliant: |
              #include <cstdint>
              struct S { };
              S* p = /*…*/;
              auto x3 = reinterpret_cast<std::uintptr_t>(p); // compliant
              auto x4 = reinterpret_cast<std::intptr_t>(p);  // compliant

      - title: "Rule 8.2.9 - The Operand to typeid Shall Not Be an Expression of Polymorphic Class Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The operand of `typeid(expr)` shall not be an expression of a polymorphic class type.
          Only non-polymorphic types or compile-time constants (type names) may be used.
        impact: |
          Using `typeid` on polymorphic types can introduce runtime overhead, potential exceptions,
          and unpredictable behavior. Restricting to non-polymorphic types ensures static resolution.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <typeinfo>
              struct P { virtual void foo() {} };  // polymorphic
              
              const std::type_info& f1(P* p) {
                  return typeid(*p);               // violation: operand is polymorphic
              }
              
              const std::type_info& f2(P p) {
                  return typeid(p);                // violation: operand is polymorphic
              }
            compliant: |
              #include <typeinfo>
              
              struct S { };                       // non-polymorphic
              
              const std::type_info& g1(const S* s) {
                  return typeid(*s);               // allowed: non-polymorphic object
              }
              
              const std::type_info& g2() {
                  return typeid(int);              // allowed: type name constant
              }

      - title: "Rule 8.2.10 - Functions Shall Not Call Themselves, Either Directly or Indirectly"
        Severity: Mandatory
        Required_Context: Multi-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Functions shall not be recursive, neither via a direct call to themselves nor
          through an indirect cycle of calls among multiple functions.

          Exception: A `constexpr` function that is only invoked within a constant expression
          may be recursively defined.
        impact: |
          Recursion can lead to unbounded stack usage and runtime failures. Since the worst-case
          stack consumption is undecidable at compile time, forbidding recursion ensures
          predictable resource usage and enhances system reliability.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  f();   // direct recursion — violation
              }

              void g();
              void h();

              void g() { h(); }
              void h() { g(); }  // indirect recursion cycle — violation
            compliant: |
              void f() {
                  process();  // no recursive calls
              }
              void process() {
                  // …
              }

              constexpr int fact(int n) {
                  return n <= 1 ? 1 : n * fact(n - 1);
              }  // permitted: constexpr recursion in a constant expression

      - title: "Rule 8.2.11 - An Argument Passed via Ellipsis Shall Have an Appropriate Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When calling a function with an ellipsis (`...`), the types of the arguments
          must be limited to those the implementation supports.  
          Prohibited types include:
          1. Class types with virtual member functions.  
          2. Class types with non‑trivial copy or move operations.  
          3. Class types with non‑trivial destructors.  
          Only fundamental types or trivially copyable, standard‑layout classes may be passed.
        impact: |
          Passing unsupported class types through an ellipsis is implementation‑defined
          or undefined, leading to data corruption, ABI mismatches, or crashes.
          Restricting ellipsis arguments to simple, trivially copyable types ensures
          portable and predictable behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdarg>
              struct A { virtual void foo() {} };      // has virtual function
              struct B { B(const B&); ~B(); };         // non-trivial copy/destructor

              void log(const char* fmt, ...);

              void f() {
                  A a;
                  log("%p\n", &a);                   // violation: A is non‑trivial
                  B b;
                  log("%p\n", &b);                   // violation: B is non‑trivial
              }
            compliant: |
              #include <cstdarg>
              struct C { int x; };                    // trivially copyable

              void log(const char* fmt, ...);

              void f() {
                  int  i = 42;
                  double d = 3.14;
                  C    c{10};

                  log("%d %f %d\n", i, d, c.x);       // allowed: fundamental and trivial types only
              }

      - title: "Rule 8.3.1 - The Built‑in Unary - Operator Shall Not Be Applied to an Expression of Unsigned Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built-in unary minus operator (`-`) shall not be applied to any operand
          of unsigned type (including after integral promotion).
        impact: |
          Preventing unary minus on unsigned values enforces clear intent and avoids
          unintended wrap-around behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              void f(int32_t);
              void f(uint32_t);

              void g(uint32_t x, uint16_t y) {
                  f(-x);    // violation: unary minus on uint32_t
                  f(-y);    // violation: unary minus on uint16_t (promoted)
              }
            compliant: |
              #include <cstdint>

              void f(int32_t);
              void f(uint32_t);

              void g(uint32_t x, uint16_t y) {
                  int32_t sx = static_cast<int32_t>(x);
                  int32_t sy = static_cast<int32_t>(y);
                  f(-sx);   // compliant: unary minus on signed type
                  f(-sy);   // compliant: unary minus on signed type
              }

      - title: "Rule 8.3.2 - The Built‑in Unary + Operator Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built-in unary plus operator (`+expr`) shall not be used.
        impact: |
          Unary plus hides implicit promotions and conversions, leading to
          unexpected overload resolution or type changes. For clarity and
          maintainability, all promotions should be spelled out via casts
          or explicit initialization.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              
              uint8_t u8a = 42;
              auto x  = +u8a;       // violation: triggers promotion to int

              auto lam = [](){};
              auto pf  = +lam;      // violation: lambda decays to function pointer
            compliant: |
              #include <cstdint>
              
              uint8_t u8a = 42;
              auto x  = static_cast<int>(u8a);    // compliant: explicit promotion

              auto lam = [](){};
              using Fn = void(*)();
              Fn pf  = static_cast<Fn>(lam);      // compliant: explicit cast to function pointer

      - title: "Rule 8.7.1 - Pointer Arithmetic Shall Not Form an Invalid Pointer"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All forms of pointer arithmetic and array indexing must produce pointers
          that point either to an element within the same array object or one past
          the last element. Any arithmetic that yields a pointer outside this
          range is prohibited.
        impact: |
          Forming pointers outside the valid range leads to undefined behavior
          on dereference, crashes, or data corruption. Enforcing this rule ensures
          memory safety and prevents out‑of‑bounds errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              int32_t arr[10] = {};
              int32_t *p1 = arr + 10;      // points one past end, permitted
              int32_t *p2 = arr + 11;      // violation: beyond one past end
              *p2 = 5;                     // undefined behavior

              int32_t a[1] = {0};
              int32_t *p3 = a - 1;         // violation: before start
            compliant: |
              int32_t arr[10] = {};
              int32_t *p1 = arr + 9;       // points to last element
              arr[5] = 42;                 // equivalent to *(arr + 5)

              int32_t a[1] = {0};
              int32_t *p2 = a + 1;         // one past end, permitted but not dereferenced

              struct S { uint16_t x, y; uint16_t a[10]; };
              S s;
              uint16_t *q1 = s.a + 9;       // last element
              uint16_t *q2 = s.a + 10;      // one past end, permitted but not dereferenced

      - title: "Rule 8.7.2 - Subtraction Between Pointers Shall Only Be Applied to Pointers That Address Elements of the Same Array"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Pointer subtraction (`p1 - p2`) shall only be used when both pointers refer
          to elements of the same array object, or one past the end of that array.
          A pointer to a non‑array object is treated as pointing to an array of length one.
        impact: |
          Subtracting pointers from different arrays (or outside the same array bounds)
          yields an undefined result. Enforcing same‑array subtraction prevents
          invalid `ptrdiff_t` values and out‑of‑bounds logic errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>
              #include <cstddef>
              
              void f(int32_t* ptr) {
                  int32_t a1[10], a2[10];
                  int32_t* p1 = &a1[1];
                  int32_t* p2 = &a2[10];
                  std::ptrdiff_t d1 = p1 - p2;   // violation: different arrays
                  std::ptrdiff_t d2 = ptr - p1;  // violation: ptr may not belong to a1
              }
            compliant: |
              #include <cstdint>
              #include <cstddef>
              
              void f(int32_t* ptr) {
                  int32_t a1[10], a2[10];
                  int32_t* p1 = &a1[1];
                  int32_t* p2 = &a1[9];
                  std::ptrdiff_t d1 = p2 - p1;   // OK: same array
                  std::ptrdiff_t d2 = (a1 + 10) - p1; // OK: one past end minus element
              }

      - title: "Rule 8.9.1 - The Built‑in Relational Operators >, >=, < and <= Shall Not Be Applied to Objects of Pointer Type Except When They Point to Elements of the Same Array"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built‑in relational operators `>`, `>=`, `<` and `<=` must not be used to compare
          two pointers unless both pointers refer to elements of the same array object (or one past
          the last element). A pointer to a non‑array object is treated as if it pointed to a
          single‑element array.
        impact: |
          Comparing unrelated pointers yields undefined or implementation‑defined behavior,
          potentially causing incorrect logic, crashes, or security vulnerabilities.
          Restricting pointer comparisons to the same array ensures defined behavior and
          prevents subtle runtime errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              int32_t a1[10], a2[10];
              int32_t* p1 = &a1[1];
              int32_t* p2 = &a2[1];

              if (p1 < p2) { /* … */ }    // violation: pointers to different arrays

              struct S { int x; } s1, s2;
              if (&s1 <= &s2) { }         // violation: pointers not within same array
            compliant: |
              int32_t a1[10];
              int32_t* p1 = &a1[1];
              int32_t* p2 = &a1[5];

              if (p1 < p2) { /* … */ }    // allowed: same array

              int32_t a2[10];
              int32_t* end = a2 + 10;
              if (end > a2) { /* … */ }   // allowed: one past end vs first element

      - title: "Rule 8.14.1 - The Right‑Hand Operand of a Logical && or || Operator Shall Not Contain Persistent Side Effects"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The right‑hand operand of the logical `&&` and `||` operators is evaluated
          only if the left‑hand operand does not determine the result. If the right‑hand
          operand performs side effects that persist (e.g., modifying non‑local state,
          performing I/O), those side effects may be skipped and lead to unpredictable
          behavior. Persistent side effects shall therefore not appear in the right‑hand
          operand of `&&` or `||`.
        impact: |
          Embedding persistent side effects in a conditional can cause operations to be
          silently skipped, resulting in inconsistent program state, missed logging or I/O,
          and hard‑to‑trace bugs. Moving side effects outside the logical expression
          ensures they always execute as intended.
        code_examples:
          # C++ examples
          - non_compliant: |
              bool ready = false;
              int counter = 0;
              // counter++ modifies state that may be skipped
              if (ready && counter++ > 0) {
                  // …
              }

              File log;
              // write_log has persistent I/O effect
              if (isError() || write_log("Error")) {
                  // …
              }
            compliant: |
              bool ready = false;
              int counter = 0;
              if (ready) {
                  ++counter;            // side effect outside logical operator
                  if (counter > 0) {
                      // …
                  }
              }

              File log;
              if (isError()) {
                  write_log("Error");   // persistent side effect moved out
                  // …
              }

      - title: "Rule 8.18.1 - An Object or Subobject Shall Not Be Copied to an Overlapping Object"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Copying an object or subobject into an overlapping memory region is prohibited.
          This can occur when:
            • A member of a union is assigned from a different member of the same union.  
            • A slice of an array is copied to an overlapping slice using `memcpy`.  
        impact: |
          Overlapping copies lead to undefined behavior:  
          – Assigning between different union members may violate the active‑member semantics.  
          – Using `memcpy` on ranges that overlap can corrupt data since it does not guarantee order of copying.  
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <array>
              union U { int16_t i; int32_t j; } u = {0};
              u.j = u.i;                                // non-compliant: union member overlap

              std::array<int16_t,20> a = {};
              memcpy(&a[0], &a[1], 10u * sizeof(a[0])); // non-compliant: overlapping memcpy
            compliant: |
              #include <array>
              union U { int16_t i; int32_t j; } u = {0};
              u.i = u.i;                                // compliant: same member copy

              std::array<int16_t,20> a = {};
              memmove(&a[0], &a[1], 10u * sizeof(a[0])); // compliant: memmove handles overlap

      - title: "Rule 8.18.2 - The Result of an Assignment Operator Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The result of any assignment operator (simple or compound, built-in or overloaded)
          shall not be used as part of another expression.
        impact: |
          Using the value of an assignment in a larger expression obscures intent,
          reduces readability, and can introduce hidden side-effects or unsequenced
          modifications that lead to undefined behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              int x, y;
              int z = (x = y);          // violation: uses assignment result in initializer

              int a, b;
              if ((a = b)) {            // violation: uses assignment result in condition
                  // …
              }
            compliant: |
              int x, y;
              x = y;
              int z = y;                // compliant: assignment and use separated

              int a, b;
              a = b;
              if (a != 0) {             // compliant: explicit comparison using the assigned value
                  // …
              }

      - title: "Rule 8.19.1 - The Comma Operator Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built-in comma operator (`expr1, expr2`) shall not be used, except within
          a fold expression (`(..., pack)`).
        impact: |
          Avoiding the comma operator in ordinary expressions improves clarity and maintainability.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f(int, int);
              f((1, 2), 3);               // violation: uses comma operator in argument

              int i = 0, j = 0;
              for (i = 0, j = 0; i < N; ++i, ++j) { }  // violation: comma operator in init and iteration
            compliant: |
              void f(int a, int b);
              f(1, 2);                    // clear argument list

              int i = 0, j = 0;
              for (; i < N; ++i, ++j) {  // initialize separately
                  // …
              }

              template<typename... Ts>
              void print_all(const Ts&... ts) {
                (print(ts), ...);          // permitted: fold expression
              }

      - title: "Rule 8.20.1 - An Unsigned Arithmetic Operation with Constant Operands Shall Not Wrap"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any built-in arithmetic operation resulting in an unsigned integer type, where
          all operands are constant expressions, shall not produce a result that wraps
          around the type’s maximum value.
        impact: |
          Undetected wrap-around can lead to unreachable code, incorrect logic, and subtle bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define BASE 65024u
              switch (x) {
                case BASE + 0u: f(); break;
                case BASE + 1u: g(); break;
                case BASE + 512u: h(); break;  // wraps to 480 on 16-bit
              }
            compliant: |
              #define BASE 65024u
              static_assert(BASE + 512u <= 65535u, "Constant sum wraps");
              switch (x) {
                case BASE + 0u: f(); break;
                case BASE + 1u: g(); break;
                case BASE + 512u: h(); break;  // safe: no wrap
              }

          - non_compliant: |
              constexpr auto DELAY  = 10000u;
              constexpr auto WIDTH  = 60000u;
              constexpr auto offtime = DELAY + WIDTH;  // wraps to 4464 on 16-bit
            compliant: |
              constexpr auto DELAY  = 10000u;
              constexpr auto WIDTH  = 20000u;            // safe sum under max
              constexpr auto offtime = DELAY + WIDTH;    // 30000u, no wrap


  - name: "4.9. Statements"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 9.2.1 - An Explicit Type Conversion Shall Not Be an Expression Statement"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Explicit type conversions using functional notation (`T(expr)` or `T{expr}`)
          shall not appear as standalone expression statements.
        impact: |
          Temporary objects created by expression-statement conversions are destructed
          immediately, triggering premature resource release and leading to logic errors
          or resource-management bugs.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <mutex>

              void example(std::mutex& m1, std::mutex& m2) {
                  std::unique_lock<std::mutex>(m1);        // locks then unlocks immediately
                  std::scoped_lock(m1, m2);                 // locks then unlocks immediately
              }
            compliant: |
              #include <mutex>

              void example(std::mutex& m1, std::mutex& m2) {
                  std::unique_lock<std::mutex> lock1(m1);   // RAII lock persists until scope exit
                  std::scoped_lock<std::mutex, std::mutex> lock2(m1, m2);
              }

      - title: "Rule 9.3.1 - The Body of an Iteration‑Statement or a Selection‑Statement Shall Be a Compound‑Statement"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The body of any iteration-statement (`while`, `do…while`, `for`) or selection-statement
          (`if`, `else if`, `switch`) shall be enclosed in braces (`{ … }`).

          _Exception_: An `else` with an explicitly empty compound-statement (`else {}`) is permitted.
        impact: |
          Omitting braces can lead to logic errors or unintended execution due to misleading indentation
          or stray semicolons.
        code_examples:
          # C++ examples
          - non_compliant: |
              while (data_available)
                  process_data();
              service_watchdog();

              if (flag_1)
                  if (flag_2)
                      action_1();
                  else
                      action_2();
            compliant: |
              while (data_available) {
                  process_data();
              }
              service_watchdog();

              if (flag_1) {
                  if (flag_2) {
                      action_1();
                  } else {
                      action_2();
                  }
              }

              // empty else allowed
              if (condition) {
                  do_something();
              } else {
              }

      - title: "Rule 9.4.1 - All if … else if Constructs Shall Be Terminated with an else Statement"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Whenever an `if` statement is followed by one or more `else if` branches,
          the sequence must be terminated with a final `else` branch.
        impact: |
          Omitting the final `else` can leave unhandled cases, resulting in
          unpredictable behavior, logic errors, or missed error handling.
          Providing an `else` documents intent and guarantees defined behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              if (x == 1) {
                  handle1();
              } else if (x == 2) {
                  handle2();
              } // missing final else

              if (flag) {
                  actionA();
              } else if (cond) {
                  actionB();
              } else if (other) {
                  actionC();
              } // no else
            compliant: |
              if (x == 1) {
                  handle1();
              } else if (x == 2) {
                  handle2();
              } else {
                  handleDefault();
              }

              // empty else is allowed if no action is needed
              if (flag) {
                  actionA();
              } else if (cond) {
                  actionB();
              } else {
              }

      - title: "Rule 9.4.2a - The Body of a switch Shall Be a Compound-Statement"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The controlled statement of a switch shall be a compound-statement `{ ... }`.
        impact: |
          Makes the structure explicit and prevents accidental binding issues.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Color { Red, Green, Blue };

              void f(Color c)
                  switch (c)            // missing braces around switch body
                      case Red:   handleRed();
                      default:    handleDefault();
            compliant: |
              enum Color { Red, Green, Blue };

              void f(Color c) {
                  switch (c) {
                  case Red:
                      handleRed();
                      break;
                  default:
                      handleDefault();
                      break;
                  }
              }

      - title: "Rule 9.4.2b - Every switch Branch Shall End with an Explicit Exit or [[fallthrough]]"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Each case or default block shall terminate with `break`, `return`, `throw`, `goto`, or `[[fallthrough]];`.
        impact: |
          Prevents unintended fall-through and clarifies control flow.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Color { Red, Green, Blue };

              void g(Color c) {
                  switch (c) {
                  case Red:
                      handleRed();      // missing exit → unintended fall-through
                  case Green:
                      handleGreen();
                      break;
                  default:
                      handleDefault();
                  }
              }
            compliant: |
              enum Color { Red, Green, Blue };

              void g(Color c) {
                  switch (c) {
                  case Red:
                      handleRed();
                      [[fallthrough]];
                  case Green:
                      handleGreen();
                      break;
                  default:
                      handleDefault();
                      break;
                  }
              }

      - title: "Rule 9.4.2c - A switch Shall Contain at Least Two Distinct Branches"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A switch statement shall include at least two distinct `case` or `default` labels.
        impact: |
          Avoids degenerate switches and ensures meaningful selection logic.
        code_examples:
          # C++ examples
          - non_compliant: |
              void h(int x) {
                  switch (x) {
                  case 1:
                      doA();
                      break;
                  }
              }
            compliant: |
              void h(int x) {
                  switch (x) {
                  case 0:
                      doZero();
                      break;
                  case 1:
                      doA();
                      break;
                  }
              }

      - title: "Rule 9.5.1 - Legacy for Statements Shall Be Simple"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A legacy `for` statement shall be “simple.” A simple legacy `for` is one whose
          init‑statement, condition, and loop‑expression meet all of:
            1. The init‑statement declares and initializes an integer loop‑counter.  
            2. The condition compares that loop‑counter to a loop‑bound via a relational operator.  
            3. The loop‑counter is modified only by increment or decrement in the loop‑expression.  
            4. Both the loop‑counter and loop‑bound are of the same type, and the bound is a
               constant or an expression that cannot overflow the type.  
            5. Neither the loop‑counter nor bound is a non‑const reference or bound to
               non‑const data.  
        impact: |
          Complex `for` loops obscure iteration logic, hinder analysis of loop bounds,
          and increase risk of off‑by‑one errors or non‑terminating loops. Restricting
          to simple legacy `for` constructs ensures predictable loop behavior and
          facilitates static checking of termination and bounds.
        code_examples:
          # C++ examples
          - non_compliant: |
              // multiple variables, non‑constant bound, complex update
              for ( int i = 0, j = 10; i + j < N; i += 2 ) 
                  process(i, j);
          - compliant: |
              // simple legacy for: single counter, constant bound, ++ update
              for ( int i = 0; i < 10; ++i ) {
                  process(i);
              }

      - title: "Rule 9.5.2 - A for‑range‑initializer Shall Contain at Most One Function Call"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a range-based `for` statement (`for ( decl : init ) statement`), the
          range initializer (`init`) shall not perform more than one function call.
          Any expression that creates an object of class type or invokes an overloaded
          operator counts as a function call.
        impact: |
          Multiple calls in the range initializer can create multiple temporaries with limited lifetimes,
          risking dangling references, premature destruction, and undefined behavior.
          Restricting to a single call ensures the loop iterates over one well-defined sequence.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <vector>
              
              std::vector<int> make_vec();
              std::vector<int> make_other();
              void process(int);
              
              void f() {
                  // two temporaries created: make_vec() and make_other()
                  for (auto &x : make_vec(), make_other()) {
                      process(x);
                  }
              }
            compliant: |
              #include <vector>
              
              std::vector<int> make_vec();
              void process(int);
              
              void f() {
                  auto vec = make_vec();            // single call, temporary persists
                  for (auto &x : vec) {
                      process(x);
                  }
              }

      - title: "Rule 9.6.1 - The goto Statement Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `goto` statement shall not be used.
        impact: |
          Eliminating `goto` improves code clarity, maintainability, and safety.
          It prevents unpredictable jumps that can bypass initialization,
          violate invariants, or complicate static analysis.
        code_examples:
          # C++ examples
          - non_compliant: |
              void process(int n) {
                  if (n < 0) goto error;
                  // … normal processing …
                  return;
              error:
                  handleError();
              }
            compliant: |
              void process(int n) {
                  if (n < 0) {
                      handleError();
                      return;
                  }
                  // … normal processing …
              }

      - title: "Rule 9.6.2 - A goto Statement Shall Reference a Label in a Surrounding Block"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A `goto` statement shall only reference a label declared in the immediately enclosing block.
        impact: |
          Restricting `goto` targets to surrounding blocks prevents jumps into or out of nested scopes,
          avoiding skipped initialization or destructor calls and clarifying control flow.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  {
                      // nested block defines label
                      goto inner;  // violation: 'inner' not in surrounding block
                  }
              inner:
                  do_something();
              }

              void g() {
                  goto external;  // violation: label not yet declared
                  int x = 0;
              external:
                  use(x);
              }
            compliant: |
              void f() {
                  // label in same block as goto
                  goto safe;
                  // …
              safe:
                  do_something();
              }

              void g() {
                  int x = 0;
                  if (x == 0) {
                      goto ok;    // 'ok' visible in surrounding block
                  }
              ok:
                  use(x);
              }

      - title: "Rule 9.6.3 - The goto Statement Shall Jump to a Label Declared Later in the Function Body"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A `goto` statement shall only transfer control forward to a label that appears later in the same function body.
        impact: |
          Preventing backward `goto` jumps eliminates unstructured iteration and hidden loops,
          ensuring all loops use well-defined language constructs for clarity and reliability.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
              start:
                  process();
                  // backward jump: 'goto start' jumps to an earlier label
                  goto start;
              }
            compliant: |
              void f() {
                  // use a while loop instead of backward goto
                  while (needProcess()) {
                      process();
                  }
              }

      - title: "Rule 9.6.4 - A Function Declared with the [[noreturn]] Attribute Shall Not Return"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any function marked `[[noreturn]]` must not return to its caller.  
          Such functions must exit by throwing, terminating the program, or looping indefinitely.
        impact: |
          Returning from a `[[noreturn]]` function results in undefined behavior
          and can lead to unpredictable control flow. Enforcing this rule ensures
          that functions intended never to return behave correctly.
        code_examples:
          # C++ examples
          - non_compliant: |
              [[noreturn]] void fail_if(bool cond) {
                  if (!cond) {
                      return;          // non‑compliant: returns despite [[noreturn]]
                  }
                  throw std::runtime_error("error");
              }
            compliant: |
              [[noreturn]] void terminate_on_error() {
                  std::abort();       // compliant: never returns
              }

              [[noreturn]] void throw_always() {
                  throw std::runtime_error("fatal"); // compliant: never returns
              }

      - title: "Rule 9.6.5 - A Function with Non‑void Return Type Shall Return a Value on All Paths"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every function whose return type is not `void` must return a value along every
          possible execution path. For lambda expressions, the compound-statement serves
          as the function body. An implicit `return 0;` at the end only applies to `main`.
        impact: |
          Missing returns lead to undefined behavior when control reaches the end of a
          non‑`void` function without a value. Enforcing explicit returns on all paths
          prevents crashes, unpredictable values, and logic errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              int compute(int x) {
                  if (x > 0) {
                      return x;
                  }
                  // missing return when x <= 0
              }
            compliant: |
              int compute(int x) {
                  if (x > 0) {
                      return x;
                  } else {
                      return 0;
                  }
              }

          - non_compliant: |
              auto f = [](bool cond) -> int {
                  if (cond) {
                      return 1;
                  }
                  // missing return when !cond
              };
            compliant: |
              auto f = [](bool cond) -> int {
                  if (cond) {
                      return 1;
                  }
                  return 2;  // covers the other path
              };


  - name: "4.10. Declarations"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 
    
      - title: "Rule 10.0.1 - A Declaration Shall Not Declare More Than One Variable or Member Variable"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An `init-declarator-list` or `member-declarator-list` shall consist of exactly one declarator.
        impact: |
          Enforcing one declarator per statement improves readability, simplifies code reviews and static checks, and reduces the risk of mis-interpreting the types or initial values of multiple identifiers.
        code_examples:
          # C++ examples
          - non_compliant: |
              int32_t i2, *j2;                     // two declarators in one statement
              
              struct Point { int32_t x, y; };      // two members declared together
            compliant: |
              int32_t i1;                          // single declarator
              int32_t j1;                          // single declarator

              struct Point {
                  int32_t x;                       // one member per declaration
                  int32_t y;
              };

      - title: "Rule 10.1.1 - The Target Type of a Pointer or lvalue Reference Parameter Shall Be Const‑Qualified Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The target type of any named pointer or lvalue reference parameter shall be
          const-qualified unless:
            1. The parameter does not refer to an object type;
            2. The parameter is assigned to a pointer or reference with a non-const target; or
            3. The function modifies the target object within its body.
        impact: |
          Declaring pointer/reference parameters as non-const when they are not modified
          can mislead users and risk unintended mutations. Enforcing const-qualification
          improves correctness and aids static analysis.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              void f(int8_t*       p1,      // compliant: p1 is modified
                     const int8_t* p2,      // compliant: p2 is read-only
                     int8_t*       p3,      // non-compliant: p3 not modified, missing const
                     int8_t* const p4,      // non-compliant: p4 pointer itself const but pointee mutable
                     int8_t        a[3])    // non-compliant: array decays to int8_t*
              {
                  *p1 = *p2 + *p3 + *p4 + a[2];
              }
            compliant: |
              #include <cstdint>

              void f(int8_t*             p1,     // compliant: p1 is modified
                     const int8_t*       p2,     // compliant: p2 is read-only
                     const int8_t*       p3,     // compliant: p3 read-only
                     const int8_t* const p4,     // compliant: p4 pointer and pointee read-only
                     const int8_t        a[3])   // compliant: array parameter is const
              {
                  *p1 = *p2 + *p3 + *p4 + a[2];
              }

      - title: "Rule 10.1.2 - The volatile Qualifier Shall Be Used Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          It is inappropriate to declare the following entities as `volatile`:
            • Local variables  
            • Function parameters  
            • Function return types  
            • Member functions  
            • Structured bindings  

          A pointer or reference _to_ a `volatile` entity is permitted.
        impact: |
          Misusing `volatile` on entities it does not apply to yields undefined or
          implementation-defined behavior and obscures intent. Enforcing correct
          `volatile` usage ensures only genuinely volatile objects (e.g., hardware
          registers) are qualified.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              void f1(volatile int32_t i)    // prohibited: parameter itself is volatile
              {
                  use(i);
              }

              volatile int32_t x = 0;        // prohibited: local variable is volatile

              volatile int32_t func();      // prohibited: return type is volatile

              struct S {
                  volatile void m();         // prohibited: member function is volatile-qualified
              };

              volatile auto [a, b] = std::pair<int, int>{1,2};  // prohibited: structured binding is volatile
            compliant: |
              #include <cstdint>

              void f2(volatile int32_t* p)   // allowed: pointer to volatile
              {
                  use(*p);
              }

              const volatile int32_t hw_reg; // hardware register at namespace scope
              volatile int32_t* p_reg = &hw_reg;  // allowed: pointer to volatile

      - title: "Rule 10.2.1 - An Enumeration Shall Be Defined with an Explicit Underlying Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every `enum` or `enum class` declaration shall include an explicit
          underlying integer type (an `enum-base`), for example:
            ```cpp
            enum Color : uint8_t { Red, Green, Blue };
            enum class Status : int32_t { Ok = 0, Error = 1 };
            ```
          
          Note: you need not specify the base when:
            1. All enumerators use only their default values (purely symbolic enums).  
            2. The enumeration is declared inside an `extern "C"` linkage specification.
        impact: |
          Without a specified underlying type, the compiler selects an implementation-
          defined integer type, which can vary across platforms. This can lead to
          unexpected overflows, ABI mismatches, and inconsistent promotions. Defining
          the base type ensures predictable size and behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Color { Red, Green, Blue };           // underlying type unknown
              enum class State { On = 1, Off = 0 };      // defaults to int
            compliant: |
              enum Color : uint8_t { Red, Green, Blue }; 
              enum class State : int32_t { On = 1, Off = 0 };

      - title: "Rule 10.2.2 - Unscoped Enumerations Shall Not Be Declared"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An unscoped `enum` (plain `enum`) shall not be used.  
          Use a scoped enumeration (`enum class`) with an explicit underlying type instead.  

          _Exception_: Unscoped enums declared as class members are exempt.
        impact: |
          Scoped enums improve namespace hygiene and enforce strong typing.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Status { Ok, Error };  // unscoped enum
              enum E : int { A, B };      // unscoped enum with underlying type
            compliant: |
              enum class Status : int { Ok, Error };  // scoped enum
              enum class E : int { A, B };           // scoped enum with underlying type

      - title: "Rule 10.2.3 - The Numeric Value of an Unscoped Enumeration with No Fixed Underlying Type Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In any evaluated context, expressions of an unscoped `enum` that lacks an
          explicit underlying type (`enum-base`) shall not be used:
            • As operands of arithmetic, bitwise, shift, logical, or compound-assignment operators;  
            • As operands of relational or equality operators, unless both sides share the same enumeration type;  
            • As the source of an assignment or a `static_cast`, unless the target is the same enumeration or an integer type capable of representing all its values;  
            • As the controlling expression of a `switch`, unless every `case` label matches an enumerator of that `enum`.  
          
          Additionally, a `static_cast` may only convert _to_ an unscoped `enum` if that `enum` has a fixed underlying type.
        impact: |
          Without a defined underlying type, unscoped enums promote unpredictably,
          risking implementation‑defined behavior, hidden wrap‑around, and platform
          mismatches. Enforcing this rule guarantees explicit conversions, preserves
          type safety, and ensures consistent behavior across platforms.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Status { Ok=0, Error=1 };

              void f() {
                  auto x = Ok + 1;                     // non‑compliant: arithmetic on unscoped enum
                  if (x == Error) { }                  // non‑compliant: relational compare after promotion
                  Status s = static_cast<Status>(x);   // non‑compliant: static_cast to enum
                  switch (s) {                         // non‑compliant: missing label for Error
                      case Ok: break;
                  }
              }
            compliant: |
              enum class Status : uint8_t { Ok=0, Error=1 };

              void f() {
                  auto x = static_cast<uint8_t>(Status::Ok) + 1;  
                  if (x == static_cast<uint8_t>(Status::Error)) { }
                  Status s = Status::Ok;              
                  switch (s) {                         
                      case Status::Ok:    break;
                      case Status::Error: break;
                  }
              }

      - title: "Rule 10.3.1 - There Shall Be No Unnamed Namespaces in Header Files"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Unnamed namespaces (`namespace { … }`) shall not be declared in header files.
        impact: |
          Prevents hidden, per-TU definitions that break linkage and cause ODR violations.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Header.hpp
              namespace {
                  inline int32_t configValue = 42;
              }

              void fn();
            compliant: |
              // Header.hpp
              namespace mylib {
                  inline int32_t configValue = 42;
              }

              void fn();

      - title: "Rule 10.4.1 - The `asm` Declaration Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The use of the `asm` declaration to embed raw assembly language is
          prohibited. Inline assembly is implementation‑defined, non‑portable, and
          can hide side‑effects from static analysis. Prefer compiler intrinsics
          or well‑tested library routines instead.
        impact: |
          Disallowing `asm` ensures that all code remains analyzable, portable,
          and maintainable. It prevents unpredictable interactions with the toolchain
          and avoids bypassing type‑ and memory‑safety guarantees of the language.
        code_examples:
          # C++ examples
          - non_compliant: |
              void delay() {
                  asm("nop");         // non‑compliant: raw assembly
              }
            compliant: |
              #include <immintrin.h>

              void delay() {
                  _mm_pause();        // compliant: using standard intrinsic
              }


  - name: "4.11. Declarators"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 11.3.1 - Variables of Array Type Shall Not Be Declared"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Variables of C-style array type shall not be declared.

          Exception: A `const` array of character type initialized with a string literal is permitted.
        impact: |
          Eliminates manual bounds management and hidden buffer-overrun risks. Promotes
          safer, self-sizing containers that integrate with the C++ type system.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              void foo() noexcept {
                  int a1[10];
                  std::uint16_t a2[5] = {};
              }

              struct S {
                  std::uint16_t a3[8];
              }
            compliant: |
              #include <array>
              #include <vector>
              #include <cstdint>

              void foo() noexcept {
                  std::array<int, 10> a1{};
                  std::vector<std::uint16_t> a2(5);
              }

              struct S {
                  std::array<std::uint16_t, 8> a3;
              }

          - non_compliant: |
              void bar() {
                  char s2[] = "abcd";
              }
            compliant: |
              void bar() {
                  const char s1[] = "abcd";
                  std::string s2 = "abcd";
              }

      - title: "Rule 11.3.2 - The Declaration of an Object Shall Contain No More Than Two Levels of Pointer Indirection"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Declarations shall not use more than two nested pointer levels.
          Any `typedef-name` is treated as if expanded to its underlying type, and
          arrays decay to pointers when used as function parameters (adding one
          level of indirection).
        impact: |
          Limiting pointer indirection to two levels keeps declarations easy to
          understand, reduces cognitive load, and helps tools generate clearer
          diagnostics. It prevents obfuscation and the mistakes that come with
          deeply nested pointer chains.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              typedef int8_t* INPTR1;
              using INPTR2 = int8_t*;

              struct S {
                  int8_t ***  p3;    // three levels → violation
              };

              void foo(int8_t***  c)  // three levels → violation
              {
                  // ...
              }

              void bar(INPTR1* p4,   // INPTR1 expands to one level, plus one → three levels
                       INPTR2* p5)   // INPTR2 expands to one level, plus one → two, plus one → three
              {
                  // ...
              }
            compliant: |
              #include <cstdint>

              struct S {
                  int8_t *   p1;    // one level
                  int8_t **  p2;    // two levels
              };

              void foo(int8_t*   a,
                       int8_t**  b)    // two levels
              {
                  // ...
              }

      - title: "Rule 11.6.1 - All Variables Shall Be Initialized"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All variables shall be initialized either explicitly or implicitly. Apart from 
          the following exceptions, every variable definition must include an initializer:
            • Variables of class type (initialized by their constructors)  
            • Function parameters (initialized by the caller)  
            • Variables with static storage duration (zero‑initialized by default)  
        impact: |
          Uninitialized variables lead to undefined behavior and unpredictable state.  
          Ensuring every variable is initialized promotes reliability, simplifies reasoning, 
          and prevents latent bugs due to reading indeterminate values.
        code_examples:
          # C++ examples
          - non_compliant: |
              void foo() {
                  int x;        // non‑compliant: x is uninitialized
                  int y;        // non‑compliant: y is uninitialized
                  x = x + 1;    // undefined behavior
              }
              void bar(int p) {
                  // compliant by exception: p is initialized by the caller
              }
            compliant: |
              void foo() {
                  int x = 0;            // compliant
                  int y{42};            // compliant
                  x = x + 1;            
              }
              void bar(int p) {
                  // still compliant
              }

          - non_compliant: |
              struct S { int m; };
              void baz() {
                  S s;                // non‑compliant: s.m is uninitialized
              }
            compliant: |
              struct S { 
                  int m{0};         // in‑class initializer
              };
              void baz() {
                  S s;                // compliant: m initialized to 0
              }

      - title: "Rule 11.6.2 - Objects Shall Not Be Read Before Being Initialized"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An object’s value shall not be read before it has been explicitly or implicitly
          set. For the purposes of this rule, each array element and each class member is
          considered a discrete object.
        impact: |
          Reading an indeterminate value results in undefined behavior. Ensuring all
          variables, members, and array elements are initialized before use improves
          code safety and predictability.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  int x;              // x is uninitialized
                  int y = x + 1;      // non-compliant: reading x before it’s set
              }

              struct S { int m; };
              void g() {
                  S s;                // s.m is uninitialized
                  int v = s.m;        // non-compliant: reading s.m before assignment
              }
            compliant: |
              void f() {
                  int x = 0;
                  int y = x + 1;      // compliant
              }

              struct S { int m; };
              void g() {
                  S s{ .m = 42 };     // explicit initializer
                  int v = s.m;        // compliant
              }

      - title: "Rule 11.6.3 - Implicitly‑Specified Enumerator Values Shall Be Unique"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Each implicitly-specified enumerator’s value shall be distinct within its enum.
        impact: |
          Duplicate enum values lead to ambiguous code, hidden logic errors, and unexpected
          behavior in switch/case and serialization logic. Enforcing unique implicit values
          prevents subtle bugs and maintains clear, predictable enumeration semantics.
        code_examples:
          # C++ examples
          - non_compliant: |
              enum Bad {
                  A = 1,    // A==1
                  B,        // B==2
                  C = 2,    // C==2 → duplicates B
                  D         // D==3
              };
            compliant: |
              enum Good {
                  A = 1,    // A==1
                  B,        // B==2
                  C = 5,    // C==5
                  D,        // D==6
                  E         // E==7
              };


  - name: "4.12. Classes"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 12.2.1 - Bit‑fields Shall Not Be Declared"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Bit-fields shall not be declared.
        impact: |
          Disallowing bit-fields enforces a predictable, portable memory layout.
          Using full-width integer members or explicit packing techniques avoids
          subtle bugs and makes data structures consistent across platforms.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Message {
                  unsigned char low  : 4;   // non-compliant: bit-field
                  unsigned char high : 4;   // non-compliant: bit-field
              };
            compliant: |
              #include <cstdint>

              struct Message {
                  uint8_t low;              // compliant: full-width member
                  uint8_t high;             // compliant: full-width member
              };

      - title: "Rule 12.2.2 - A Bit‑Field Shall Have an Appropriate Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Bit‑fields shall be declared only with types whose width and signedness
          are fully specified and portable. Permitted types are:
          • Signed and unsigned integer types  
          • bool  
          • Scoped enums with an explicit fixed underlying integer type whose range
            fits within the bit‑field width  
        impact: |
          Using well-defined underlying types for bit‑fields avoids implementation‑defined
          packing, padding, and signedness, ensuring structures have predictable,
          portable layouts and preventing subtle bugs when interfacing with hardware
          or serializing data.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdint>

              enum Direction { Top, Left, Bottom, Right };

              struct Bad {
                  char c         : 2;   // non‑compliant: 'char' signedness is implementation‑defined
                  unsigned char u: 3;   // non‑compliant: 'unsigned char' not a permitted bit‑field type here
                  char32_t x     : 2;   // non‑compliant: 'char32_t' not allowed
                  Direction dir  : 4;   // non‑compliant: unscoped enum without explicit underlying type
              };
            compliant: |
              #include <cstdint>

              enum class Colour : uint8_t { Red, Green, Blue };

              struct Good {
                  signed int    a     : 2;  // compliant: signed integer
                  unsigned int  b     : 3;  // compliant: unsigned integer
                  int32_t       c     : 4;  // compliant: fixed‑width integer
                  bool          flag  : 1;  // compliant: bool
                  Colour        color : 2;  // compliant: scoped enum with explicit underlying type
              };

      - title: "Rule 12.2.3 - A Named Bit‑Field with Signed Integer Type Shall Not Have a Length of One Bit"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Named bit-fields declared with a signed integer type shall not have a width of exactly one bit.
        impact: |
          Prohibiting single-bit signed bit-fields avoids ambiguous sign interpretation,
          eliminates a common source of subtle bugs, and ensures that all named
          fields reliably represent the intended range of values.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct S {
                  signed int a : 1;  // non-compliant: named signed bit-field of width 1
              };
            compliant: |
              struct S {
                  signed int b : 2;  // compliant: named signed bit-field width > 1
              };

      - title: "Rule 12.3.1 - The union Keyword Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `union` keyword shall not be used.
        impact: |
          Prohibiting unions eliminates a common source of unpredictable behavior,
          simplifies object lifetime handling, and enforces type safety by using
          standard library constructs.
        code_examples:
          # C++ examples
          - non_compliant: |
              union Data1 {
                  int32_t i;
                  float   j;
              };
            compliant: |
              using Data2 = std::variant<int32_t, float>;


  - name: "4.13. Derived Classes"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 
    
      - title: "Rule 13.1.1 - Classes Shall Not Be Inherited Virtually"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Virtual inheritance of base classes shall not be used.
        impact: |
          Disallowing virtual inheritance enforces simpler, more predictable
          class hierarchies and reduces runtime and memory costs.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A {
                  virtual int32_t foo() { return 1; }
              };
              
              struct B : public virtual A {    // non-compliant: virtual inheritance
                  int32_t goo() { return foo(); }
              };
              
              struct C : public virtual A {    // non-compliant: virtual inheritance
                  int32_t foo() override { return 2; }
              };
              
              struct D : public C, public B {   // non-compliant: diamond with virtual bases
              };
            compliant: |
              struct A {
                  virtual int32_t foo() { return 1; }
              };
              
              struct B : public A {             // compliant: non-virtual inheritance
                  int32_t goo() { return foo(); }
              };
              
              struct C : public A {             // compliant: non-virtual inheritance
                  int32_t foo() override { return 2; }
              };
              
              struct D : public C, public B {   // compliant: diamond without virtual bases
              };

      - title: "Rule 13.1.2 - An Accessible Base Class Shall Not Be Both Virtual And Non‑Virtual In The Same Hierarchy"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A base class shall not be inherited both virtually and non-virtually
          within the same inheritance hierarchy.
        impact: |
          Disallowing mixed virtual and non-virtual inheritance enforces a clear,
          unambiguous object layout and prevents runtime errors due to multiple
          or merged base class subobjects.
        code_examples:
          # C++ examples
          - non_compliant: |
              class A {};

              class B1 : public virtual A {};   // virtual A
              class B2 : public virtual A {};   // virtual A
              class B3 : public      A  {};     // non-virtual A

              class C : public B1, B2, B3 {};   // violation: A inherited both ways
            compliant: |
              class A {};

              // Only virtual inheritance
              class V1 : public virtual A {};
              class V2 : public virtual A {};
              class CV : public V1, public V2 {};  // compliant: only virtual A

              // Only non-virtual inheritance
              class N1 : public A {};
              class N2 : public A {};
              class CN : public N1, public N2 {};  // compliant: only non-virtual A

      - title: "Rule 13.3.1 - User‑Declared Member Functions Shall Use virtual, override And final Specifiers Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Member function declarations must include the correct specifier based on whether they
          introduce a new virtual function or override an existing one:
          
          1. If a function does **not** override a base-class virtual function, it shall either
             have no specifier or be marked `virtual`.
          2. If a function **overrides** a base-class virtual function, it shall **not** use
             `virtual`, and **must** use either `override` or `final`.
        impact: |
          Enforcing explicit and correct use of `virtual`, `override`, and `final` ensures
          clear intent in class interfaces, prevents inadvertent overrides or omissions,
          and avoids ill-formed or ambiguous polymorphic behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              // New virtual marked with override, and override without override specifier
              class A {
              public:
                  virtual void g() override; // non-compliant: 'override' on new virtual
              };

              class B : public A {
              public:
                  void g() { /*…*/ }           // non-compliant: overrides without 'override'
              };
            compliant: |
              class A {
              public:
                  virtual void f();          // compliant: new virtual function
                  void      g();             // compliant: new non-virtual function
              };

              class B : public A {
              public:
                  void f() override;         // compliant: correct override
                  void g();                  // compliant: does not override
              };

      - title: "Rule 13.3.2 - Parameters in an Overriding Virtual Function Shall Not Specify Different Default Arguments"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Each parameter in an overriding virtual function shall either:
            1. Not specify a default argument; or
            2. Use a constant expression for its default argument, with the same value as in the base declaration.
        impact: |
          Prevents inconsistent default values between base and derived overrides so that calls
          through either static or dynamic type use identical defaults, avoiding surprising behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              int32_t x();

              class Base {
              public:
                  virtual void process(int32_t a = 0);
              };

              class Derived : public Base {
              public:
                  void process(int32_t a = 1) override;  // non‑compliant: default (1) differs from Base (0)
              };
            compliant: |
              int32_t x();

              class Base {
              public:
                  virtual void process(int32_t a = 0);
              };

              class Derived : public Base {
              public:
                  void process(int32_t a = 0) override;  // compliant: same default as Base
              };

      - title: "Rule 13.3.3 - The Parameters in All Declarations or Overrides of a Function Shall Either Be Unnamed or Have Identical Names"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Each parameter in all declarations or overrides of a function shall either be unnamed
          or have the exact same name in every declaration or override.
        impact: |
          Consistent parameter naming prevents confusion and ensures that declarations
          and overrides match reliably.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Renamed parameters in two overloads
              void CreateRectangle(uint32_t Height, uint32_t Width);
              void CreateRectangle(uint32_t Width, uint32_t Height);  // non-compliant: names swapped

              // Override uses a different name
              class Shape {
                  virtual void draw(Canvas& destination) = 0;
              };
              class Rectangle : public Shape {
                  void draw(Canvas& canvas) override;  // non-compliant: 'canvas' ≠ 'destination'
              }
            compliant: |
              // Unnamed or consistently named parameters
              void fn1(int32_t);                   
              void fn1(int32_t);                   // compliant: both unnamed

              // Override uses identical parameter name
              class Shape {
                  virtual void draw(Canvas& destination) = 0;
              };
              class Rectangle : public Shape {
                  void draw(Canvas& destination) override;  // compliant: identical name
              }

      - title: "Rule 13.3.4 - A Comparison of a Potentially Virtual Pointer to Member Function Shall Only Be With nullptr"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A pointer-to-member-function that could refer to a virtual function shall only be compared to nullptr.
        impact: |
          Ensures that such comparisons are well-defined and avoids unspecified behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              class A {
              public:
                  void f1();
                  void f2();
                  virtual void f3();
              };

              void foo() {
                  if (&A::f3 == &A::f2) { }   // non-compliant: comparing virtual to non-virtual
              }

              void bar(void (A::*ptr)()) {
                  if (ptr == &A::f2) { }      // non-compliant: ptr might refer to virtual f3
              }
            compliant: |
              class A {
              public:
                  void f1();
                  void f2();
                  virtual void f3();
              };

              void foo() {
                  if (&A::f1 != &A::f2) { }  // allowed: both non-virtual
                  if (&A::f3 == nullptr) { } // allowed: compare to nullptr
              }

              void bar(void (A::*ptr)()) {
                  if (ptr == nullptr) { }     // allowed: only compare to nullptr
              }


  - name: "4.14. Member Access Control"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 14.1.1 - Non‑static Data Members Shall Be Either All private or All public"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Within a class, non‑static data members shall not mix `public` and `private`
          access. All non‑static data members of a class must be declared either all
          `public` or all `private`, but not both.
        impact: |
          Ensures consistent encapsulation and a clear interface for classes. Avoiding
          mixed access specifiers prevents accidental misuse of internal state and
          simplifies reasoning about invariants and maintenance.
        code_examples:
          # C++ examples
          - non_compliant: |
              class C1 {
              public:
                  int32_t a;
              private:
                  int32_t b;
              };
            compliant: |
              class C2 {
              public:
                  C2(int32_t a, int32_t b) : a{a}, b{b} {}
              private:
                  int32_t a;
                  int32_t b;
              };


  - name: "4.15. Special Member Functions"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 
    
      - title: "Rule 15.0.1a - Special Member Function Definitions Shall Reside in a Single File"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All out-of-class definitions of a class’s destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator shall be placed in the same translation unit.
        impact: |
          Centralizing special member definitions ensures consistency and simplifies code navigation.
        code_examples:
          # C++ examples
          - non_compliant: |
              // X.hpp
              struct X {
                  X(const X&);
                  X(X&&) noexcept;
                  ~X();
              };
              // X_copy.cpp
              #include "X.hpp"
              X::X(const X&){ /* copy ctor */ }
              // X_move.cpp
              #include "X.hpp"
              X::X(X&&) noexcept{ /* move ctor */ }
              // X_dtor.cpp
              #include "X.hpp"
              X::~X(){ /* dtor */ }
            compliant: |
              // X.hpp
              struct X {
                  X(const X&);
                  X(X&&) noexcept;
                  ~X();
              };
              // X.cpp
              #include "X.hpp"
              X::X(const X&){ /* copy ctor */ }
              X::X(X&&) noexcept{ /* move ctor */ }
              X::~X(){ /* dtor */ }

      - title: "Rule 15.0.1b - User‑Provided Copy/Move Operations Require a User‑Provided Destructor"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          If a class provides a user-defined (non-=default) copy constructor, copy assignment operator, move constructor, or move assignment operator, it shall also provide a user-defined (non-=default) destructor.
        impact: |
          Enforcing a matching custom destructor prevents leaks and double-frees when a class manages resources.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Buffer {
                  int *data;
                  Buffer(const Buffer& other)
                    : data(new int(*other.data)) {}   // user-provided copy ctor
                  // missing user-provided destructor → potential leak
              };
            compliant: |
              struct Buffer {
                  int *data;
                  Buffer(const Buffer& other)
                    : data(new int(*other.data)) {}   // user-provided copy ctor
                  ~Buffer() {                        // user-provided dtor
                      delete data;
                  }
              };
              
      - title: "Rule 15.0.1c - User‑Provided Destructor Definitions Shall Not Be Empty"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any user-provided destructor shall contain at least one statement other than an empty compound statement (`{}`) or a null statement (`;`).
        impact: |
          Prevents “phantom” destructors that appear custom but perform no work, which can mislead maintainers and break resource management invariants.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdlib>

              struct Manager {
                  void* resource_;
                  Manager(void* r) : resource_(r) {}
                  ~Manager() {}   // non-compliant: empty destructor
              };
          - compliant: |
              #include <cstdlib>

              struct Manager {
                  void* resource_;
                  Manager(void* r) : resource_(r) {}
                  ~Manager() {    // compliant: performs actual cleanup
                      std::free(resource_);
                  }
              };
              
      - title: "Rule 15.0.1d - Public Base Classes Require Appropriate Destructor Specification"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A class intended for use as a public base shall either:
          1. Be uncopyable and unmovable, and declare a `public virtual` destructor
          2. Declare a `protected non-virtual` destructor
        impact: |
          Ensures safe polymorphic destruction and prevents resource leaks or crashes
          when derived objects are deleted via base-class pointers.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Base {
                  ~Base() {}        // non-compliant: destructor must be virtual
              };

              struct Derived : public Base {
                  ~Derived() {}     // never called when deleted via Base*
              };

              void f() {
                  Base* p = new Derived;
                  delete p;        // undefined behavior: Derived::~Derived() is not invoked
              }
            compliant: |
              // Option 1: uncopyable/unmovable + public virtual destructor
              struct Base {
                  Base(const Base&) = delete;
                  Base(Base&&)      = delete;
                  virtual ~Base()   = default;
              };
              
              struct Derived : public Base {
                  ~Derived() override = default;
              };

              // Option 2: protected non-virtual destructor
              struct Interface {
              protected:
                  ~Interface() = default;
              };
              
              struct Impl : public Interface {
              public:
                  ~Impl() = default;   // compliant: no override on a non-virtual base dtor
              };

    
      - title: "Rule 15.0.2 - User‑provided copy and move member functions of a class should have appropriate signatures"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When a class X defines its own special-member functions (copy constructor, move constructor,
          copy-assignment operator or move-assignment operator), each user-provided declaration shall use
          the canonical C++ signature:

            • Copy constructor:      X(const X&);
            • Move constructor:      X(X&&) noexcept;
            • Copy assignment:       X& operator=(const X&) noexcept;
            • Move assignment:       X& operator=(X&&) noexcept;

          It is permitted to add `constexpr`, `explicit` (for constructors) or conditional `noexcept`, but
          not to take non-const or extra parameters, nor to return `void` from an assignment operator.
        impact: |
          Enforcing these standard signatures avoids ambiguous or dangerous copy/move operations,
          prevents dangling references from temporary assignment results, and clarifies exception
          guarantees, leading to more maintainable and predictable code.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct S {
                  S(S&);                    // wrong: non-const copy constructor
                  S(const S&, int = 0);     // wrong: extra/default parameter
                  S& operator=(S&&);        // wrong: missing noexcept on move assignment
                  void operator=(const S&); // wrong: returns void
              };
            compliant: |
              struct S {
                  S(const S&);                        // copy constructor
                  S(S&&) noexcept;                    // move constructor
                  S& operator=(const S&) noexcept;    // copy assignment
                  S& operator=(S&&) noexcept;         // move assignment
              };
    
      - title: "Rule 15.1.1 - An object’s dynamic type shall not be used from within its constructor or destructor"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Do not invoke virtual calls, apply `dynamic_cast`, or use `typeid` on `*this`
          inside its own constructor or destructor.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <typeinfo>

              struct Base {
                  virtual void f() {}
                  virtual ~Base() {}
              };

              struct Derived : Base {
                  Derived() {
                      f();                              // non-compliant: virtual call in ctor
                      auto d = dynamic_cast<Derived*>(this); // non-compliant: dynamic_cast in ctor
                  }
                  ~Derived() {
                      auto& ti = typeid(*this);        // non-compliant: typeid in dtor
                  }
              };
            compliant: |
              struct Base {
                  void f() {}            // non-virtual
                  virtual ~Base() {}
              };

              struct Derived : Base {
                  Derived() {
                      Base::f();         // compliant: non-virtual call
                  }
                  ~Derived() {}
              };

      - title: "Rule 15.1.2 - All constructors of a class shall explicitly initialize all of its virtual base classes and immediate base classes"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All user‑provided (non‑defaulted) constructors must explicitly initialize
          each direct base class—both virtual bases and immediate (non‑virtual) bases—
          using the member‑initializer list or by delegating to another constructor.
        impact: |
          Prevents ambiguity over which base constructors run and with what arguments,
          ensuring a predictable and consistent object construction order.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A { };
              struct B : virtual A { };
              struct C : B {
                  C() { }    // neither A nor B is explicitly initialized
              };
            compliant: |
              struct A { };
              struct B : virtual A {
                  B() : A() { }
              };
              struct C : B {
                  C() : A(), B() { }  // A and B both explicitly initialized
              };

      - title: "Rule 15.1.3 - Conversion Operators and Single‑Argument Constructors Shall Be Explicit"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any constructor or conversion operator that can be called with a single
          argument must be declared `explicit`.
        impact: |
          Requiring `explicit` on single-argument constructors and conversion operators
          avoids unexpected type conversions, improves readability, and reduces hidden
          bugs caused by silent conversions.
        code_examples:
          # C++ examples
          - non_compliant: |
              class C {
              public:
                  C(int32_t a);            // non-compliant: single-argument constructor
                  operator bool() const;   // non-compliant: conversion operator
              };
            compliant: |
              class D {
              public:
                  explicit D(int32_t a);          // compliant
                  explicit operator bool() const; // compliant
              };

      - title: "Rule 15.1.4 - All Direct, Non‑Static Data Members Shall Be Initialized Before Object Is Accessible"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every direct, non-static data member of a class must be initialized
          before the object becomes accessible (i.e. at the start of the constructor
          body or via aggregate initialization).
        impact: |
          Fully initializing all members enforces class invariants, prevents
          reads of indeterminate values, and makes compliance checks decidable.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <string>
              
              class Person {
              public:
                  Person(const std::string& name, int32_t age)
                    : name{name}             // 'age' and 'income' left uninitialized
                  { }
              
              private:
                  std::string name;
                  int32_t    age;
                  int32_t    income;        // no initializer
              };
            compliant: |
              #include <string>
              
              class Person {
              public:
                  Person(const std::string& name, int32_t age)
                    : name{name}
                    , age{age}
                    , income{1000}          // all members initialized
                  { }
              
              private:
                  std::string name;
                  int32_t    age;
                  int32_t    income = 1000;
              };

      - title: "Rule 15.1.5 - A Class Shall Only Define an Initializer‑List Constructor When It Is the Only Constructor"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A class may provide a constructor taking a `std::initializer_list<T>` only if
          it defines no other constructors (apart from defaulted copy/move constructors and
          the implicit default constructor).
        impact: |
          Prevents ambiguous or unintended constructor selection that can result in subtle
          bugs, unexpected element counts, and maintenance difficulties.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <initializer_list>

              struct S {
                  S(int x) {}                              // non-compliant: ordinary constructor
                  S(std::initializer_list<int> v) {}       // initializer-list constructor
              };
            compliant: |
              #include <initializer_list>

              struct A {
                  A(std::initializer_list<int> v) {}       // compliant: only initializer-list
              };

              struct B {
                  B(int x) {}                             // compliant: only ordinary constructor
              };
  
      - title: "Rule 15.1.8 - User‑Provided Copy and Move Assignment Operators Shall Handle Self‑Assignment"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any user‑provided copy assignment operator (`operator=(const X&)`) or move
          assignment operator (`operator=(X&&)`) must correctly handle self‑assignment.
          Assigning an object to itself shall not cause undefined behavior, resource leaks,
          or alter the value of the object.
        impact: |
          Ensures safe, predictable copy/move semantics by preventing crashes, memory
          corruption, and leaks when an object is assigned to itself.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct Vector {
                  std::size_t size_;
                  int32_t* buffer_;
                  Vector& operator=(const Vector& other) & {
                      // non‑compliant: deletes own buffer on self‑assignment
                      delete[] buffer_;
                      size_   = other.size_;
                      buffer_ = new int32_t[size_];
                      std::copy_n(other.buffer_, size_, buffer_);
                      return *this;
                  }
              };
            compliant: |
              struct Vector {
                  std::size_t size_;
                  int32_t* buffer_;
                  // Self‑assignment check
                  Vector& operator=(const Vector& other) & {
                      if (this != &other) {
                          delete[] buffer_;
                          size_   = other.size_;
                          buffer_ = new int32_t[size_];
                          std::copy_n(other.buffer_, size_, buffer_);
                      }
                      return *this;
                  }
                  // Or copy‑and‑swap idiom
                  Vector& operator=(Vector other) & {
                      using std::swap;
                      swap(size_,   other.size_);
                      swap(buffer_, other.buffer_);
                      return *this;
                  }
              };
    
   
  - name: "4.16. Overloading"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 16.5.1 - The Logical AND and Logical OR Operators Shall Not Be Overloaded"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The built-in `&&` and `||` operators shall not be overloaded.
        impact: |
          Preventing overloads of `&&` and `||` ensures developers can rely on the language’s
          built-in short-circuit semantics and preserves common control-flow expectations.
        code_examples:
          # C++ examples
          - non_compliant: |
              class FuzzyBool {};
              bool operator&&(FuzzyBool fb, bool b) { /* ... */ }

              template <class Vehicle>
              void f(Vehicle &v) {
                  if (v.isOvertaking() && v.increaseSpeed()) {
                      // non-compliant: operator&& is overloaded
                  }
              }
            compliant: |
              template <class Vehicle>
              void f(Vehicle &v) {
                  if (v.isOvertaking()) {
                      if (v.increaseSpeed()) {
                          // compliant: built-in && with short-circuit
                      }
                  }
              }

      - title: "Rule 16.5.2 - The Address‑Of Operator Shall Not Be Overloaded"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Overloading the built-in address-of operator (`&`) is prohibited.
        impact: |
          Disallowing overloads of `operator&` preserves the guaranteed semantics
          of pointer address retrieval and ensures that `&obj` always yields the
          actual memory address of `obj`.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct S {
                  int operator&() const { return 42; }
              };
              S s;
              auto x = &s;   // non-compliant: calls user-defined operator&()
            compliant: |
              struct S { int value; };
              S s;
              auto p = &s;   // compliant: built-in address-of, p is S*

      - title: "Rule 16.6.1 - Symmetrical Operators Shall Only Be Implemented as Non‑Member Functions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Symmetrical binary operators (e.g. `+`, `-`, `*`, `/`, `%`, `==`, `!=`, `<`, `<=`, `>`, `>=`, `^`, `&`, `|`, `&&`, `||`)  
          must be defined as non-member functions rather than as member functions.
        impact: |
          Defining symmetrical operators as non-members ensures that `a + b` and `b + a`
          always resolve to the same overload, preventing asymmetrical implicit conversions.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct C {
                  int value;
                  C(int v) : value(v) {}
                  C operator+(const C& rhs) const {  // non-compliant: member operator+
                      return C(value + rhs.value);
                  }
              };
              C a(1), b(2);
              auto x1 = a + b;
              auto x2 = b + a;  // may call different overloads
            compliant: |
              struct C {
                  int value;
                  C(int v) : value(v) {}
                  friend C operator+(const C& lhs, const C& rhs) {  // compliant: non-member
                      return C(lhs.value + rhs.value);
                  }
              };
              C a(1), b(2);
              auto x1 = a + b;
              auto x2 = b + a;
    

  - name: "4.17. Templates"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 17.8.1 - Function Templates Shall Not Be Explicitly Specialized"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Function templates (including member function templates) shall not be explicitly
          specialized using the `template<>` syntax.
        impact: |
          Disallowing explicit function template specializations ensures that overloads—
          which participate in the primary overload resolution phase—are used consistently,
          avoiding surprising call resolutions and making the code’s intent clear.
        code_examples:
          # C++ examples
          - non_compliant: |
              // free function template + explicit specialization
              template<typename T>
              void f1(T);
              
              template<> 
              void f1<char*>(char*);    // non-compliant: explicit specialization
            compliant: |
              // free function template + overload instead
              template<typename T>
              void f1(T);
              
              void f1(char*);           // compliant: overload, not specialization
    

  - name: "4.18. Exception Handling"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 18.1.1 - Exception Objects Shall Not Have Pointer Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Exception objects thrown by a `throw` expression shall not have pointer type.
        impact: |
          Ensuring exceptions are thrown by value makes ownership explicit,
          avoids resource-management ambiguity, and prevents undefined behavior
          caused by dangling or incorrectly freed pointers.
        code_examples:
          # C++ examples
          - non_compliant: |
              class A {};
              void f(int16_t i) {
                  static A a1;
                  A * a2 = new A;
                  if (i > 0) {
                      throw &a1;    // non-compliant: pointer thrown
                  } else {
                      throw a2;     // non-compliant: pointer thrown
                  }
              }
            compliant: |
              class A {};
              void f(int16_t i) {
                  A a1;
                  if (i > 0) {
                      throw a1;                       // compliant: thrown by value
                  } else {
                      throw std::runtime_error("err"); // compliant: value type
                  }
              }

      - title: "Rule 18.1.2 - An Empty throw Shall Only Occur Within a catch Handler"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An empty throw (`throw;`) shall only appear inside the compound-statement of a `catch` handler.
        impact: |
          Restricting empty `throw` expressions to `catch` blocks ensures that only
          valid exception re-throws occur, preventing unexpected termination and
          making exception propagation explicit.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  // No active exception
                  throw;    // non-compliant: empty throw outside catch
              }
            compliant: |
              void g() {
                  try {
                      // ...
                  }
                  catch (const std::exception& e) {
                      log(e.what());
                      throw;  // compliant: re-throws within catch
                  }
              }

      - title: "Rule 18.3.1 - There Shall Be at Least One Exception Handler to Catch All Otherwise Unhandled Exceptions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `main` function (or designated program entry point) shall include a
          `try { … } catch(...)` block to catch any exceptions not handled elsewhere.
        impact: |
          Providing a “last‐ditch” catch‐all in the entry point ensures consistent
          cleanup, allows logging or error reporting, and prevents silent crashes
          due to unhandled exceptions.
        code_examples:
          # C++ examples
          - non_compliant: |
              int main() {
                  std::vector<int> data = fetchData(); // may throw
                  process(data);
                  return 0;
              }
            compliant: |
              int main() {
                  try {
                      std::vector<int> data = fetchData();
                      process(data);
                      return 0;
                  }
                  catch (const std::exception& e) {
                      std::cerr << "Unhandled exception: " << e.what() << "\n";
                      return 1;
                  }
                  catch (...) {
                      std::cerr << "Unknown exception occurred\n";
                      return 1;
                  }
              }

      - title: "Rule 18.3.2 - Exception Objects of Class Type Shall Be Caught by const Reference"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Exceptions of class type shall be caught by reference (typically `const T&`)
          rather than by value.
        impact: |
          Catching exceptions by reference preserves the full object state,
          ensures correct dispatch of virtual functions, avoids unnecessary copies,
          and reduces risk of slicing or data races when sharing exception objects.
        code_examples:
          # C++ examples
          - non_compliant: |
              try {
                  mayThrow();
              }
              catch (std::runtime_error e) {   // non-compliant: caught by value
                  std::cerr << e.what();
              }
            compliant: |
              try {
                  mayThrow();
              }
              catch (const std::exception& e) { // compliant: caught by const reference
                  std::cerr << e.what();
              }

      - title: "Rule 18.3.3 - Function‑Try‑Block Handlers in Constructors/Destructors Shall Not Access Non‑Static Members"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a function-try-block of a constructor or destructor, the `catch` handler
          must not read or write any non-static data members or base-class members.
        impact: |
          Enforcing this rule prevents undefined behavior and potential crashes
          caused by accessing members of an object that is not fully constructed
          or has already been partially destroyed.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct C {
                  int32_t x;
                  C() try : x(mayThrow()) {
                  }
                  catch (...) {
                      if (x == 0) {               // non-compliant: x may not exist
                          cleanup();
                      }
                  }
                  ~C() try {
                      // destructor body
                  }
                  catch (...) {
                      log(x);                    // non-compliant: x may be destroyed
                  }
              };
            compliant: |
              struct C {
                  static void reportError();
                  C() try {
                      initialize();
                  }
                  catch (...) {
                      reportError();              // compliant: no access to non-static members
                  }
                  ~C() try {
                      cleanup();
                  }
                  catch (...) {
                      reportError();              // compliant
                  }
              };

      - title: "Rule 18.4.1a – Static/Thread-Storage Initialization Functions Shall Be noexcept"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any function or constructor directly (or indirectly) invoked to initialize
          a non-`constexpr`, non-local variable with static or thread storage duration
          must be marked `noexcept`.
        impact: |
          Prevents unexpected exceptions during static initialization or thread setup,
          avoiding unpredictable program termination.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <string>

              // Global static: the constructor for std::string may throw
              static std::string globalName = []{
                  return std::string("Korbit");
              }();
              
              // Thread-local static: std::vector push_back may allocate and throw
              thread_local std::vector<int> threadData = []{
                  std::vector<int> v;
                  v.push_back(42);
                  return v;
              }();
            compliant: |
              #include <string>

              struct SafeString {
                  SafeString(const char* s) noexcept : str{s} {}
                  std::string str;
              };

              // Global static initialized via a noexcept constructor
              static SafeString globalName{"Korbit"};

              struct SafeData {
                  SafeData() noexcept { data.reserve(1); }
                  std::vector<int> data;
              };

              // Thread-local static initialized via a noexcept constructor
              thread_local SafeData threadData;

      - title: "Rule 18.4.1b – Destructors and Special Member Functions Shall Be noexcept"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All destructors, all copy-constructors of exception objects, all move-constructors,
          and all move-assignment operators shall be `noexcept`, either implicitly or explicitly.
        impact: |
          Guarantees that destruction and object transfers never throw, ensuring
          exception-safe stack unwinding and object movement.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct E : std::exception {
                  ~E() override {}   // implicit noexcept(false)
              };
            compliant: |
              struct E : std::exception {
                  ~E() noexcept override {}
              };

      - title: "Rule 18.4.1c – swap Functions Shall Be noexcept"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any free or member function named `swap` shall be declared `noexcept`.
        impact: |
          Ensures that `std::swap` and algorithmic swaps cannot throw, preserving
          container invariants and enabling strong exception safety.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct M {
                  friend void swap(M& a, M& b) { /* ... */ }
              };
            compliant: |
              struct M {
                  friend void swap(M& a, M& b) noexcept { /* ... */ }
              };

      - title: "Rule 18.5.1 – `noexcept` Functions Shall Not Propagate Exceptions"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A function declared `noexcept` must not allow an exception to escape.
        impact: |
          Prevents unexpected program termination by ensuring `noexcept`
          functions catch all exceptions internally or avoid throwing.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() noexcept {
                  mayThrow();  // if this throws, std::terminate is called
              }
            compliant: |
              void f() noexcept {
                  try {
                      mayThrow();
                  } catch (...) {
                      // handle or swallow
                  }
              }

      - title: "Rule 18.5.2 – Program‑Terminating Functions Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A program shall not call the C++ termination functions `std::abort`, `std::exit`, `_Exit`, `std::quick_exit`, or `std::terminate`, nor take their address.
        impact: |
          Prevents hard-to-detect resource leaks and inconsistent state by ensuring all clean-up and error handling occurs via standard exception propagation or controlled shutdown logic.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdlib>
              
              void shutdown() {
                  std::abort();  // non-compliant: abrupt termination
              }

              void fail() {
                  std::terminate(); // non-compliant: bypasses destructors
              }
            compliant: |
              #include <stdexcept>
              
              void shutdown() {
                  throw std::runtime_error("Shutting down due to error");
              }

              void fail() {
                  // perform cleanup, then propagate
                  throw std::logic_error("Failure occurred");
              }


  - name: "4.19. Preprocessing Directives"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 19.0.1 – Lines Starting with `#` Shall Be Valid Preprocessor Directives"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every line in a translation unit whose first non-whitespace token is `#` must form a syntactically valid preprocessor directive.
        impact: |
          Ensures that all conditional compilation and macro definitions are correctly recognized by the compiler, preventing hidden bugs and build inconsistencies.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define MAX 10

              int32_t foo()
              {
                  int32_t x = 0;

              #ifndef MAX
                  x = 1;
              #else1       // non-compliant: typo in directive name
                  x = MAX;
              #endif

                  return x;
              }
            compliant: |
              #define MAX 10

              int32_t foo()
              {
                  int32_t x = 0;

              #ifndef MAX
                  x = 1;
              #else        // compliant: correct directive
                  x = MAX;
              #endif

                  return x;
              } 
 
      - title: "Rule 19.0.2 – Function‑Like Macros Shall Not Be Defined"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Function-like macros (macros taking parentheses and parameters) shall not be defined.
        impact: |
          Prevents subtle bugs caused by unintended multiple evaluations, lack of type checking, name collisions, and maintenance difficulties associated with macros.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define SQUARE(x) ((x)*(x))      // non-compliant: function-like macro
              #define LOG(msg) printf("%s\n", msg)  // non-compliant
              
              int main() {
                  int a = 5;
                  int b = SQUARE(a + 1);    // macro expands unpredictably
                  LOG("Done");               // macro call
                  return 0;
              }
            compliant: |
              constexpr int square(int x) { return x * x; }      // compliant: constexpr function
              inline void log(const char* msg) { puts(msg); }    // compliant: inline function
              
              int main() {
                  int a = 5;
                  int b = square(a + 1);   // safe, type-checked call
                  log("Done");             // safe, scoped call
                  return 0;
              }

      - title: "Rule 19.0.3 – #include Directives Shall Only Be Preceded by Preprocessor Directives or Comments"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All `#include` directives shall appear only at the top of a source file or
          immediately after other preprocessor directives or comments. No active code
          (declarations, definitions, or expressions) shall appear before an `#include`
          directive.
        impact: |
          Groups header inclusions in a single, predictable location, improving
          readability, preventing hidden dependencies, and avoiding undefined behavior
          caused by including standard headers after code.
        code_examples:
          # C++ examples
          - non_compliant: |
              // f.h
              void foo();

              // f.cpp
              int globalValue = 42;      // active code before include → violation
              #include "f.h"             // non-compliant: include after code

              int main() {
                  foo();
                  return 0;
              }
            compliant: |
              // f.h
              void foo();

              // f.cpp
              #include "f.h"             // compliant: include at top

              int globalValue = 42;
              
              int main() {
                  foo();
                  return 0;
              }

      - title: "Rule 19.0.4 - `#undef` Shall Only Be Used for Macros Defined Previously in the Same File"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An `#undef` directive shall only be applied to a macro that has been
          defined earlier in the same translation unit.
        impact: |
          Restricting `#undef` to locally defined macros preserves clarity of macro scope,
          avoids accidental removal of external definitions, and reduces the risk of subtle build or runtime errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              // File.cpp
              #include "ExternalDefs.h"   // ExternalDefs.h defines EXTERNAL_MACRO
              #undef EXTERNAL_MACRO       // non-compliant: EXTERNAL_MACRO was not defined in this file
          - compliant: |
              // File.cpp
              #define LOCAL_MACRO(x) ((x) + 1)
              // ... use LOCAL_MACRO ...
              #undef LOCAL_MACRO          // compliant: LOCAL_MACRO was defined earlier in this file
 
      - title: "Rule 19.1.1 - The `defined` Preprocessor Operator Shall Be Used Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The only valid forms of the `defined` operator in a `#if` or `#elif`
          directive are:
          
            defined(identifier)
            defined identifier
          
          The token `defined` must not be generated by macro expansion and the
          argument must be a simple identifier (not a literal, expression, or
          parenthesized expression).
        impact: |
          Ensuring `defined` is used correctly prevents undefined preprocessing
          behavior, guards against accidental macro-generated tokens, and keeps
          conditional-compilation logic clear and reliable.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Using a literal instead of an identifier:
              #if defined 1
              #endif

              // Macro generates a `defined` token – not allowed:
              #define MYTEST(x) defined(x) && ((x) != 0)
              #if MYTEST(FOO)
              #endif
            compliant: |
              // Correct use with parentheses:
              #if defined(FOO)
              #endif

              // Correct use without parentheses:
              #if defined BAR
              #endif

              // Macro-based test must not re‑emit `defined`:
              #define IS_ENABLED(x) ((x) != 0)
              #if defined(FOO) && IS_ENABLED(FOO)
              #endif

      - title: "Rule 19.1.2 - `#else`, `#elif`, and `#endif` Must Reside in the Same File as Their Corresponding `#if`/`#ifdef`/`#ifndef`"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every `#else`, `#elif`, and `#endif` directive must appear in the same
          source file as the matching `#if`, `#ifdef`, or `#ifndef`. Conditional
          blocks shall not span multiple files; each `#if` family block must be
          fully contained and terminated within one translation unit.
        impact: |
          Confined conditional directives prevent mismatches and hidden errors,
          simplify maintenance by keeping each conditional’s start and end co‑located,
          and improve readability by avoiding fragmented preprocessing logic.
        code_examples:
          # C++ examples
          - non_compliant: |
              // file: a.h
              #ifndef A_H
              #define A_H

              void foo();

              // file: b.cpp
              #include "a.h"
              #endif  // Non‑compliant: #endif for A_H in a different file

              // file: feature.h
              #ifdef FEATURE_X
              // …

              // file: feature.cpp
              #elif defined(OTHER)  // Non‑compliant: #elif split across files
              // …
              #endif
            compliant: |
              // single file: example.h
              #ifndef EXAMPLE_H
              #define EXAMPLE_H

              void foo();

              #ifdef FEATURE_X
                // …
              #elif defined(OTHER)
                // …
              #endif  // closes FEATURE_X

              #endif  // closes EXAMPLE_H

      - title: "Rule 19.1.3 - Identifiers in `#if`/`#elif` Must Be Defined Before Use"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every identifier used in the controlling expression of an `#if` or `#elif`
          directive must have been defined before it is evaluated.
        impact: |
          Requiring all identifiers in `#if`/`#elif` expressions to be pre-defined
          prevents accidental misconfiguration, ensures that conditional compilation
          only occurs when explicitly enabled, and avoids subtle bugs due to
          implicit zero-value assumptions.
        code_examples:
          # C++ examples
          - non_compliant: |
              // No definition of FEATURE before use ⇒ treated as 0
              #if FEATURE == 1      // non-compliant: FEATURE is undefined
              void foo();
              #endif

              #if M == 0            // non-compliant: M is not defined, assumed zero
              void bar();
              #endif
            compliant: |
              #define FEATURE 1     // FEATURE explicitly defined
              #if FEATURE == 1     // compliant
              void foo();
              #endif

              // Compiler or build system defines DEBUG via –DDEBUG
              #ifdef DEBUG          // compliant: DEBUG is known to be defined
              void debugLog();
              #endif

      - title: "Rule 19.2.1 - Header Files Shall Be Guarded Against Multiple Inclusion"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every header file must use an inclusion guard (`#ifndef`/`#define`/`#endif` or `#pragma once`).
        impact: |
          Enforcing inclusion guards avoids multiple-definition errors, reduces build
          complexity, and ensures headers can be safely included in any order or depth
          of nested includes.
        code_examples:
          # C++ examples
          - non_compliant: |
              // File: Widget.hpp
              struct Widget { int x; };

              // File: main.cpp
              #include "Widget.hpp"
              #include "Widget.hpp"  // non-compliant: no guard ⇒ redefinition
            compliant: |
              // File: Widget.hpp
              #ifndef WIDGET_HPP
              #define WIDGET_HPP

              struct Widget { int x; };

              #endif // WIDGET_HPP

              // File: main.cpp
              #include "Widget.hpp"
              #include "Widget.hpp"  // compliant: guard prevents redefinition

      - title: "Rule 19.2.2 - #include Directive Shall Use Only `<filename>` or \"filename\""
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          After preprocessing, every `#include` directive must expand to one of these valid forms:

            #include <filename>
            #include "filename"
        impact: |
          Prevents malformed include directives, ensures the compiler reliably locates headers,
          and avoids undefined behavior caused by ill-formed includes.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define HEADER "my_hdr.h"
              #include HEADER          // non-compliant: expands to identifier, not string

              #define PATH <config.h>
              #include PATH            // non-compliant: expands to angle-bracket list

              #define INC(fname) <##fname##>
              #include INC(utils.h)    // non-compliant: macro-generated form
            compliant: |
              #include <vector>       // compliant
              #include "MyClass.hpp"  // compliant

      - title: "Rule 19.2.3 - Header File Names Shall Not Contain Quotes, Backslashes, or Comment Sequences"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In a `#include` directive, the header‐name token between `<...>` or `"..."` must not contain:

            • Single-quote (`'`)
            • Double-quote (`"`)
            • Backslash (`\`)
            • C-style comment open (`/*`)
            • C-style comment close (`*/`)
            • C++-style comment (`//`)
        impact: |
          Enforces portable and unambiguous header names for reliable preprocessing.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include "fi'le.h"       // contains single-quote
              #include "fi\"le.h"      // contains embedded double-quote
              #include "path\file.h"   // contains backslash
              #include <pa/*th>.h>     // contains C-style comment
              #include <pa//th.h>      // contains C++-style comment
            compliant: |
              #include "file.h"
              #include "path/file.h"
              #include <vector>

      - title: "Rule 19.3.1 - The `#` and `##` Preprocessor Operators Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          In macro definitions, the `#` (stringize) and `##` (token-paste) operators shall not be used.
        impact: |
          Prevents ambiguities and ensures predictable preprocessing.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define TO_STRING(x)   # x
              #define CONCAT(a, b)   a ## b
              TO_STRING(foo + bar);     // uses `#`
              CONCAT(my, Var);          // uses `##`
            compliant: |
              #include <string>
              
              inline std::string to_string_value(int x) {
                  return std::to_string(x);
              }
              
              inline std::string concat_str(const std::string& a, const std::string& b) {
                  return a + b;
              }
              
              void example() {
                  auto s = to_string_value(foo + bar);
                  auto p = concat_str("my", "Var");
              }

      - title: "Rule 19.3.2 - A Macro Parameter Immediately Following `#` Shall Not Be Immediately Followed by `##`"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Combining the stringizing operator (`#`) and token‑pasting operator (`##`)
          in sequence (i.e. `#x##y`) leads to unspecified evaluation order and invalid
          preprocessing tokens. A macro parameter that is stringized must not be
          directly joined to another token via `##`.
        impact: |
          Preventing `#` followed immediately by `##` ensures that stringized tokens
          remain valid string literals and eliminates ambiguities in macro expansion.
          This avoids hard‑to‑diagnose preprocessing errors and enhances portability.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define MAKE_STR(x)       #x
              #define COMBINE(a, b)     a ## b
              #define BAD_MACRO(x, y)   #x ## y
              
              // Usage:
              BAD_MACRO(foo, bar);     // non‑compliant: `#x ## y` combines `#foo` and `bar`
            compliant: |
              #define MAKE_STR(x)       #x
              #define COMBINE(a, b)     a ## b
              #define GOOD_MACRO(x, y)  COMBINE(MAKE_STR(x), y)
              
              // Usage:
              GOOD_MACRO(foo, bar);    // compliant: expands `COMBINE("foo", bar)`

      - title: "Rule 19.3.3 - Mixed‑Use Macro Parameters Shall Not Be Subject to Further Expansion"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A macro parameter used as an operand to `#` or `##` shall not also appear elsewhere
          in the same replacement list unquoted.
        impact: |
          Ensures uniform macro expansion and avoids inconsistent behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define MIXED(x)   x # x
              
              #define HELLO     world
              
              MIXED(HELLO);    // first `x` → world, second `#x` → "HELLO"
          - compliant: |
              // Parameter only appears with stringizing, never unquoted
              #define QUOTE(x)   #x
              QUOTE(HELLO);    // expands to "HELLO"
              
              // Parameter only appears with token-pasting, never unquoted
              #define PASTE(x)   x ## _suffix
              PASTE(HELLO);    // expands to HELLO_suffix

      - title: "Rule 19.3.4 - Parentheses Shall Be Used to Ensure Macro Arguments Are Expanded Appropriately"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Macro parameters that may expand into expressions containing operators
          of precedence 2–13 must be wrapped in parentheses.  
          Alternatively, they may be stringified via `#` to prevent further parsing.
        impact: |
          Ensures that macro arguments are treated as single units, avoiding
          unexpected operator-precedence issues during expansion.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define M1(x, y)   ( x * y )
              
              int r = M1(1 + 2, 3);   // expands to (1 + 2 * 3) == 7, not 9
            compliant: |
              #define M2(x, y)   ( (x) * (y) )
              
              int r = M2(1 + 2, 3);   // expands to ((1 + 2) * (3)) == 9

      - title: "Rule 19.3.5 - Tokens That Look Like a Preprocessing Directive Shall Not Occur Within a Macro Argument"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          A macro argument shall not contain sequences of tokens that would
          be recognized as preprocessing directives (e.g. `#ifdef`, `#else`, `#endif`).
        impact: |
          Prevents macro arguments from embedding directive-like tokens that
          can break builds or cause confusing preprocessor behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #define M(A) printf("%s\n", #A)
              int main() {
                  M(
                    #ifdef SW
                    "Enabled"
                    #else
                    "Disabled"
                    #endif
                  );
              }
            compliant: |
              #define M(A) printf("%s\n", A)
              int main() {
                  M("SW defined?");    // simple literal, no directive tokens
              }

      - title: "Rule 19.6.1 - The #pragma Directive and the _Pragma Operator Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `#pragma` directive and the `_Pragma` operator shall not be used.
        impact: |
          Prevents reliance on compiler-specific pragmas, improving portability.
        code_examples:
          # C++ examples
          - non_compliant: |
              #pragma once                   // non-compliant: implementation-defined
              #define P(x) _Pragma(#x)      // non-compliant: uses _Pragma operator
              _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
            compliant: |
              // No use of #pragma or _Pragma
              // Use standard include guards instead:
              #ifndef MY_HEADER_HPP
              #define MY_HEADER_HPP
              // … header contents …
              #endif


  - name: "4.21. Language Support Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 21.2.1 - The Library Functions `atof`, `atoi`, `atol` and `atoll` from `<cstdlib>` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The functions `std::atof`, `std::atoi`, `std::atol` and `std::atoll` (and their
          equivalents in `<stdlib.h>`) shall not be called, nor shall their addresses
          be taken or shadowed by macros.
        impact: |
          Use safer C++ conversions (`std::from_chars`, `std::stoi`, etc.) for well-defined behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdlib>
              #include <string>

              int parse(const std::string &s) {
                  return std::atoi(s.c_str());   // non-compliant
              }

              double toD(const char *p) {
                  return std::atof(p);           // non-compliant
              }
            compliant: |
              #include <charconv>
              #include <string>
              #include <system_error>
              #include <cstring>

              int parse(const std::string &s) {
                  int value{};
                  auto  [ptr, ec] = std::from_chars(s.data(), s.data() + s.size(), value);
                  if (ec != std::errc()) {
                      throw std::invalid_argument("Invalid integer: " + s);
                  }
                  return value;
              }

              double toD(const char *p) {
                  double value{};
                  auto   [ptr, ec] = std::from_chars(p, p + std::strlen(p), value);
                  if (ec != std::errc()) {
                      throw std::invalid_argument("Invalid float: " + std::string(p));
                  }
                  return value;
              }

      - title: "Rule 21.2.2 - The String‑Handling Functions from `<cstring>`, `<cstdlib>`, `<cwchar>` and `<cinttypes>` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The legacy C string-handling functions (e.g., `strcpy`, `strlen`, `strcat`,
          `strtol`, `wcscpy`, `strtoumax`, etc.) from `<cstring>`, `<cstdlib>`, `<cwchar>`
          and `<cinttypes>` shall not be called, their addresses shall not be taken,
          and no macro shall shadow their names.
        impact: |
          Using these functions can lead to buffer overflows, undefined behavior,
          and security vulnerabilities due to lack of bounds checking.  
          Avoiding them improves memory safety, prevents subtle bugs, and enables
          clearer error handling in C++ code.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstring>
              #include <cstdlib>

              void foo(char *dst, const char *src, std::size_t n) {
                  std::strcpy(dst, src);           // non-compliant
                  auto len = std::strlen(src);     // non-compliant
              }

              void bar(const char *s) {
                  long x = std::strtol(s, nullptr, 10);  // non-compliant
              }
            compliant: |
              #include <string>
              #include <string_view>
              #include <charconv>
              #include <system_error>
              #include <cstring>    // for std::memcpy only

              void foo(char *dst, const char *src, std::size_t n) {
                  std::string_view sv{src};
                  if (sv.size() >= n) {
                      throw std::length_error("source too long");
                  }
                  std::memcpy(dst, sv.data(), sv.size());
                  dst[sv.size()] = '\0';
              }

              void bar(const char *s) {
                  std::string_view sv{s};
                  int value{};
                  auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), value);
                  if (ec != std::errc()) {
                      throw std::invalid_argument("invalid integer");
                  }
              }

      - title: "Rule 21.2.3 - The `system` Function from `<cstdlib>` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The C library function `system()` shall not be called, its address shall not be taken, and no macro shall shadow its name.
        impact: |
          Calling `system()` can introduce shell-injection vulnerabilities and uncontrolled execution of external commands, risking security and stability.  
          Avoiding `system()` improves safety by using well-defined, exception-safe APIs for process control.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdlib>

              void launch_shell() {
                  int ret = std::system("rm -rf /");     // non-compliant
                  auto fn = &std::system;                // non-compliant
              }
          - compliant: |
              #include <filesystem>
              #include <iostream>

              void list_directory(const std::filesystem::path &dir) {
                  for (const auto &entry : std::filesystem::directory_iterator(dir)) {
                      std::cout << entry.path().string() << "\n";
                  }
              }

      - title: "Rule 21.2.4 - The `offsetof` Macro Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `offsetof` macro shall not be used.
        impact: |
          Using `offsetof` can produce undefined behavior for non-standard-layout types,
          break encapsulation, and result in non-portable code. Avoiding `offsetof`
          improves type safety and ensures member offsets are computed in a well-defined manner.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstddef>

              struct A {
                  int32_t i;
              };

              void f() {
                  std::size_t off = offsetof(A, i);   // non-compliant
              }
          - compliant: |
              #include <cstdint>
              #include <iostream>

              struct A {
                  int32_t i;
                  static constexpr std::uintptr_t offset_i() noexcept {
                      // fallback definition, if desired
                      return 0;
                  }
              };

              void f_compliant() {
                  A a{42};
                  // pointer-to-member for 'i'
                  auto pm = &A::i;
                  // compute offset at runtime in a defined manner
                  const char* base   = reinterpret_cast<const char*>(&a);
                  const char* member = reinterpret_cast<const char*>(&(a.*pm));
                  std::size_t off    = static_cast<std::size_t>(member - base);
                  std::cout << "offset of i: " << off << "\n";
              }


      - title: "Rule 21.6.0a - Every `new` Allocation Shall Have a Matching `delete`"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Every object allocated with `new` or `new[]` must be deallocated exactly once with the matching `delete` or `delete[]`.
        impact: |
          Ensures that dynamically allocated memory is reclaimed, preventing resource exhaustion and logical corruption.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  int* p = new int(42);
                  // missing delete
              }
            compliant: |
              void f() {
                  int* p = new int(42);
                  // use p
                  delete p;
              }

      - title: "Rule 21.6.0b - Double or Invalid Deletes Shall Not Occur"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          An object shall be deallocated exactly once. Attempting to `delete` (or `delete[]`)
          the same pointer more than once, or deleting a pointer not obtained from `new`,
          results in undefined behavior.
        impact: |
          Prevents corruption of the allocator’s internal structures and avoids
          undefined behavior that can crash or corrupt memory.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  int* p = new int;
                  delete p;
                  delete p;          // double delete
              }
            compliant: |
              void f() {
                  int* p = new int;
                  delete p;          // exactly one delete
                  p = nullptr;       // null out to avoid reuse
              }

      - title: "Rule 21.6.0c - Use‑After‑Free Shall Not Occur"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Once memory has been deallocated via `delete` or `delete[]`, the pointer shall
          not be dereferenced or used in any way. Such use‑after‑free results in undefined
          behavior.
        impact: |
          Eliminates hard‑to‑debug crashes and security vulnerabilities caused by
          accessing freed memory.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  int* p = new int(1);
                  delete p;
                  int x = *p;       // use‑after‑free
              }
            compliant: |
              void f() {
                  int* p = new int(1);
                  int x = *p;       // use before delete
                  delete p;
                  p = nullptr;      // avoid dangling
              }

      - title: "Rule 21.6.0d - No Implicit Ownership Leaks Across Exception Paths"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any `new`ed object must have a clear ownership and be released even if exceptions
          are thrown. Prefer RAII (e.g. `std::unique_ptr`, `std::vector`) over raw `new`/`delete`.
        impact: |
          Guarantees that exceptions do not cause memory leaks, improving robustness
          and exception‑safety.
        code_examples:
          # C++ examples
          - non_compliant: |
              void f() {
                  int* p = new int[10];
                  throw std::runtime_error("oops"); // leak: delete never called
              }
            compliant: |
              void f() {
                  auto p = std::make_unique<int[]>(10);
                  throw std::runtime_error("oops"); // auto‑deleted
              }

      - title: "Rule 21.6.1 - Dynamic Memory Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any use of dynamic storage duration via `new`, `delete`, `malloc`, `free`, C allocators (`calloc`, `realloc`, `aligned_alloc`), or any facility that allocates on the heap (e.g., `std::vector`, `std::string`, `std::make_unique`, etc.) is prohibited.
        impact: |
          Avoids fragmentation, resource exhaustion, and non-deterministic execution times. Enforces use of compile-time or static storage, or predictable custom allocators.
        code_examples:
          # C++ examples
          - non_compliant: |
              int* p = new int(42);
              delete p;

              std::vector<int> v = {1,2,3};

              void* buf = std::malloc(256);
              std::free(buf);

              auto sp = std::make_unique<int>(10);
            compliant: |
              int x = 42;

              static int buf[256];

              ArenaAllocator arena;
              int* p = arena.allocate<int>();
              arena.deallocate(p);

      - title: "Rule 21.6.2 - Dynamic Memory Shall Be Managed Automatically"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Explicit calls to any non‑placement form of `new`/`delete`, the C allocators  
          (`malloc`, `calloc`, `realloc`, `aligned_alloc`, `free`), `std::pmr::memory_resource`  
          allocations, or `std::unique_ptr::release()` are prohibited. All heap‑allocated  
          resources must be owned and released automatically via RAII types (e.g.  
          `std::make_unique`, `std::vector`, `std::pmr` containers) or user‑provided  
          scoped allocators.
        impact: |
          Ensures no manual memory management errors (leaks, double‑free, dangling ptrs),  
          increases exception safety, and guarantees deterministic destruction of  
          allocated resources.
        code_examples:
          # C++ examples
          - non_compliant: |
              struct A { /*…*/ };

              // Direct malloc/free
              void* raw = std::malloc(sizeof(A));
              std::free(raw);

              // Raw new/delete
              A* p = new A;
              delete p;

              // Releasing unique_ptr
              auto up = std::make_unique<A>();
              A* r = up.release();  // non-compliant

              // pmr allocation
              std::pmr::memory_resource& mr = /*…*/;
              void* buf = mr.allocate(sizeof(A));
              mr.deallocate(buf, sizeof(A));
            compliant: |
              struct A { /*…*/ };

              // Automatic smart-pointer management
              auto up2 = std::make_unique<A>();

              // Container-managed allocation
              std::vector<A> v;
              v.emplace_back();

              // pmr container
              std::pmr::unsynchronized_pool_resource pool;
              std::pmr::vector<A> vp(&pool);
              vp.emplace_back();

      - title: "Rule 21.6.3 - Advanced Memory Management Functions Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any direct use or address‑taking of advanced memory management hooks is prohibited.  
          This includes overloads of `operator new`/`operator delete` beyond the basic forms,  
          `std::launder`, and the low‑level `<memory>` functions:
          
            - `uninitialized_default_construct[_n]`, `uninitialized_value_construct[_n]`,  
              `uninitialized_copy[_n]`, `uninitialized_move[_n]`, `uninitialized_fill[_n]`,  
              `destroy[_n]`
          
          Advanced management occurs when any of these functions are:
            1. Called directly (or via a `new-expression`/`delete-expression`).
            2. Have their address taken.
            3. Used in a user‑defined destructor.
        impact: |
          Prevents subtle alignment, lifetime, and exception‑safety pitfalls that arise  
          from low‑level allocator hooks, and keeps memory management centrally handled  
          by high‑level RAII constructs.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <memory>
              #include <new>
              
              void f(int* ptr) {
                  int buf[5];
                  std::uninitialized_copy_n(ptr, 5, buf);    // non-compliant
              }
              
              // Overloaded operator new beyond basic form
              void* operator new(std::size_t, std::align_val_t) {
                  return std::malloc( /* … */ );
              }
              
              auto fn = &std::destroy<int>;               // non-compliant: address taken
              
              struct S {
                  int member;
                  ~S() {
                      std::destroy_at(&member);            // non-compliant: used in destructor
                  }
              };
            compliant: |
              #include <vector>
              
              void f(int* ptr) {
                  std::vector<int> v;
                  v.reserve(5);
                  v.insert(v.end(), ptr, ptr + 5);        // compliant: high-level RAII
              }
              
              // Rely on default global operator new/delete (no custom overloads)
              
              struct S {
                  MemberType member;                      // default destructor
              };

      - title: "Rule 21.6.4 - If a Project Defines Either a Sized or Unsized Version of Global `operator delete`, Then Both Shall Be Defined"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          When you provide a global `operator delete`, you must supply both the sized and the unsized overload.
        impact: |
          Ensuring both overloads exist guarantees that every `delete` expression has a well-defined deallocation target, preventing subtle runtime errors and undefined behavior across different compilers or build configurations.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Only unsized delete provided
              void operator delete(void* p) noexcept {
                  std::free(p);
              }
            compliant: |
              // Unsized delete
              void operator delete(void* p) noexcept {
                  std::free(p);
              }
              // Sized delete
              void operator delete(void* p, std::size_t) noexcept {
                  operator delete(p);
              }

      - title: "Rule 21.6.5 - A Pointer to an Incomplete Class Type Shall Not Be Deleted"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          You must not apply the `delete` operator to a pointer whose target class type is incomplete at the point of deletion.
        impact: |
          Preventing deletion of incomplete types avoids undefined behavior related to missing destructor calls or mismatched deallocation routines, ensuring safe and predictable object cleanup.
        code_examples:
          # C++ examples
          - non_compliant: |
              // Header.hpp
              class Impl;            // forward declaration
              class Bad {
                  Impl *pImpl;
              public:
                  ~Bad() { delete pImpl; }  // non-compliant: Impl is incomplete here
              };
            compliant: |
              // Impl.hpp
              class Impl { /*...*/ };
              // Bad.hpp
              #include "Impl.hpp"
              class Good {
                  Impl *pImpl;
              public:
                  ~Good() { delete pImpl; }  // compliant: Impl is complete here
              };
    
      - title: "Rule 21.10.1 - Variadic `<cstdarg>` Features Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Do not use any of the `<cstdarg>` features (`va_list`, `va_start`, `va_arg`, `va_end`, `va_copy`) or their C equivalents.
        impact: |
          Eliminating `<cstdarg>` usage enforces strong type safety, prevents undefined behavior from incorrect variadic argument handling, and ensures all function parameters are checked at compile time.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdarg>
              int sum(int count, ...) {
                  va_list args;                  
                  va_start(args, count);         
                  int total = 0;
                  for (int i = 0; i < count; ++i) {
                      total += va_arg(args, int); 
                  }
                  va_end(args);                   // added to avoid coding mistake
                  return total;                   // still non-compliant: variadic usage prohibited
              }
            compliant: |
              #include <vector>
              int sum(const std::vector<int>& values) {
                  int total = 0;
                  for (int v : values) {
                      total += v;
                  }
                  return total;
              }

      - title: "Rule 21.10.2 - `<csetjmp>` Facilities Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Do not use the standard header `<csetjmp>` or any of its facilities (`setjmp`, `longjmp`).
        impact: |
          Disallowing `<csetjmp>` enforces structured, RAII-based control flow, guarantees proper destructor invocation, prevents resource leaks, and avoids hard-to-diagnose undefined behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <csetjmp>
              jmp_buf buf;
              void f() {
                  if (setjmp(buf) != 0) {
                      // skipped stack unwinding -> destructors not called
                  }
              }
              void g() {
                  longjmp(buf, 1); // non-compliant
              }
            compliant: |
              #include <stdexcept>
              void f() {
                  try {
                      throw std::runtime_error("error");
                  } catch (...) {
                      // proper unwinding -> destructors called
                  }
              }
              void g() {
                  // use exception or other structured control flow instead
              }

      - title: "Rule 21.10.3 - `<csignal>` Facilities Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Do not use any facilities from `<csignal>` or `<signal.h>`.
          _Exception_: Calling `signal(sig, SIG_IGN)` to ignore a signal is permitted.
        impact: |
          Disallowing `<csignal>` enforces exception-based error handling and RAII,
          guarantees proper destructor invocation, prevents resource leaks, and
          avoids unpredictable program behavior due to signals.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <csignal>
              void handler(int) { /* ... */ }
              void setup() {
                  std::signal(SIGTERM, handler);  // non-compliant: installing custom handler
              }
          - compliant: |
              #include <csignal>

              void setup_ignore() {
                  // permitted: explicitly ignore SIGTERM without custom handler
                  std::signal(SIGTERM, SIG_IGN);
              }

              #include <stdexcept>

              void perform_work() {
                  try {
                      // ... application logic ...
                  }
                  catch (const std::exception &e) {
                      // handle errors via exceptions, not signals
                      std::cerr << "Error: " << e.what() << "\n";
                  }
              }


  - name: "4.22. Diagnostics Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 

      - title: "Rule 22.3.1 - `assert` Macro Shall Not Be Used With a Constant‑Expression"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `assert` macro shall not be used with a constant-expression.

          _Exception_: It is permitted to write `assert(false)` or `assert(false && "any string literal")`
          to mark code paths that should never be reached.
        impact: |
          Using `static_assert` for constant checks ensures errors are caught during
          compilation, improving code safety and preventing run-time failures that
          are harder to diagnose.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cassert>

              void f(int32_t i)
              {
                  assert(sizeof(int) == 4);    // non-compliant: constant expression
                  assert(i < 1000);            // compliant: i is not constant
              }
            compliant: |
              static_assert(sizeof(int) == 4, "Bad size");  // compile-time check

              #include <cassert>

              void f(int32_t i)
              {
                  assert(i < 1000);            // compliant: non-constant expression
              }

      - title: "Rule 22.4.1 - Literal Zero Shall Be the Only Value Assigned to `errno`"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Within user code, the only literal value that may be assigned to `errno` is zero.  
          Non-zero values must not be set directly, as the C++ library itself may set `errno`  
          to indicate errors; user code should use more robust error‑handling mechanisms  
          (e.g. exceptions or `std::error_code`).

          _Note_: The C++ Standard Library is permitted to assign non‑zero values to `errno`.  
        impact: |
          Direct assignment of non‑zero literals to `errno` conflicts with library usage,  
          can mask real errors, and leads to fragile, hard‑to‑maintain code.  
          Enforcing zero‑only assignments preserves the integrity of the error indicator.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cerrno>
              #include <string>

              std::string getKey(const std::optional<std::string>& key_data)
              {
                  if (key_data.has_value() && !key_data->empty())
                      return *key_data;
                  errno = 42;             // non‑compliant: assigning non‑zero literal
                  errno = EINVAL;          // non‑compliant: non‑zero constant
                  return {};
              }

              #define OK 0
              void f()
              {
                  unsigned success = 0;
                  errno = success;        // non‑compliant: success is variable, not literal '0'
                  errno = OK;             // non‑compliant: OK expands to literal '0' only if defined correctly
              }
            compliant: |
              #include <cerrno>

              void f()
              {
                  errno = 0;              // compliant: only literal zero assigned
              }


  - name: "4.23. General Utilities Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies: 

      - title: "Rule 23.11.1 - Raw Pointer Constructors of `std::shared_ptr` and `std::unique_ptr` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The constructors of `std::shared_ptr` and `std::unique_ptr` that take a raw pointer
          shall not be used. Instead, use `std::make_shared<T>(...)` and `std::make_unique<T>(...)`.
        impact: |
          Avoiding raw-pointer constructors prevents potential resource leaks and double-free
          errors. Using `make_shared`/`make_unique` yields stronger exception-safety guarantees.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <memory>

              struct A { A(int); };

              void f()
              {
                  auto p1 = std::shared_ptr<A>(new A(42));   // non-compliant
                  auto p2 = std::unique_ptr<A>(new A(7));    // non-compliant
              }
            compliant: |
              #include <memory>

              struct A { A(int); };

              void f()
              {
                  auto p1 = std::make_shared<A>(42);         // compliant
                  auto p2 = std::make_unique<A>(7);          // compliant
              }


  - name: "4.24. Strings Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 24.5.1 - Character Classification and Case Mapping Functions from `<cctype>`/`<cwctype>` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          All character‑handling functions from the headers `<cctype>` and `<cwctype>`
          (and their C equivalents `<ctype.h>` and `<wctype.h>`) are prohibited.
          These include functions like `std::isdigit`, `std::isalpha`, `std::toupper`,
          `std::towlower`, and their variants.  
          Instead, use the locale‑aware facilities in `<locale>` (e.g., `std::ctype<char>`,
          `std::use_facet<std::ctype<char>>(...)`) or appropriate Unicode libraries
          that provide well‑defined behavior for character classification and
          case conversion.

        impact: |
          The standard `<cctype>`/`<cwctype>` functions invoke undefined behavior
          when called with values that are not representable as `unsigned char`
          or equal to `EOF`. Locale‑aware facets and modern Unicode APIs handle
          character ranges robustly, prevent UB, and support internationalization.

        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cctype>

              void f(char c)
              {
                  if (std::isdigit(c))         // non‑compliant
                      ; 
                  c = std::toupper(c);         // non‑compliant
              }
            compliant: |
              #include <locale>

              void f(char c)
              {
                  std::locale loc{};
                  const auto& facet = std::use_facet<std::ctype<char>>(loc);
                  if (facet.is(std::ctype_base::digit, static_cast<unsigned char>(c)))
                      ;
                  c = facet.toupper(static_cast<unsigned char>(c));  // compliant
              }

      - title: "Rule 24.5.2 – The C++ Standard Library functions `memcpy`, `memmove` and `memcmp` from `<cstring>` Shall Not Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The functions `memcpy`, `memmove` and `memcmp` from `<cstring>` are prohibited,
          as they can lead to undefined behavior when used on overlapping, non‑trivially
          copyable, or partially initialized buffers. Instead, use safe C++ alternatives
          such as `std::copy`, `std::equal` or container member functions that enforce
          bounds and compatibility.
        impact: |
          Prohibiting raw memory operations prevents buffer over‑runs, hidden overlaps,
          and incorrect comparisons. Using C++ algorithms enhances type safety, clarity,
          and allows static analysis to catch out‑of‑bounds or semantic errors.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstring>
              void f(char *dst, const char *src, std::size_t n) {
                  std::memcpy(dst, src, n);       // non‑compliant
              }
              bool eq(const int *a, const int *b, std::size_t n) {
                  return std::memcmp(a, b, n * sizeof(int)) == 0;  // non‑compliant
              }
              void g(char *buf, std::size_t n) {
                  std::memmove(buf + 1, buf, n);  // non‑compliant if regions overlap
              }
            compliant: |
              #include <algorithm>
              #include <iterator>
              bool eq(const std::vector<int> &a, const std::vector<int> &b) {
                  return a.size() == b.size() &&
                         std::equal(a.begin(), a.end(), b.begin());
              }
              void f(std::span<char> dst, std::span<const char> src) {
                  std::copy(src.begin(), src.end(), dst.begin());  // safe copy
              }
              void g(std::vector<char> &buf) {
                  std::rotate(buf.begin(), buf.begin(), buf.begin() + 1);  // safe shift
              }


  - name: "4.25. Localization Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 25.5.1 – The `setlocale` and `std::locale::global` Functions Shall Not Be Called"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The functions `setlocale` and `std::locale::global` shall not be called.
          Instead, use locale-aware facets or pass a `std::locale` object explicitly to I/O and formatting APIs.
        impact: |
          Preventing global locale changes avoids hidden side‐effects and data races.
          Explicitly specifying locales ensures thread‐safe and predictable behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <clocale>
              void f() {
                  setlocale(LC_ALL, "ja_JP.utf8");       // non-compliant: global C‐library locale change
                  std::locale::global(std::locale("de_DE"));  // non-compliant: global C++ locale change
                  // This call now uses the modified global locale:
                  bool ws = std::iswspace(L' ');          
              }
            compliant: |
              #include <locale>
              #include <sstream>
              void f() {
                  // Explicit per‐object locale, no globals modified
                  std::locale loc("en_US.utf8");
                  bool ws = std::use_facet<std::ctype<wchar_t>>(loc)
                                .is(std::ctype_base::space, L' ');
                  
                  std::ostringstream oss;
                  oss.imbue(loc);
                  oss << 1234.56;  // formatting uses the explicit locale
              }

      - title: "Rule 25.5.2 – Pointers Returned by `localeconv`, `getenv`, `setlocale` or `strerror` Shall Only Be Used as if Pointing to `const`-Qualified Type"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Pointers returned by `localeconv`, `getenv`, `setlocale` or `strerror` shall be used only as if pointing to a `const`-qualified type. They shall not be written through, and their addresses shall not be taken.
        impact: |
          Treating these results as read-only prevents inadvertent modification of internal/static data and enables tools to detect illegal writes.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <clocale>
              #include <cstdlib>
              #include <cstring>
              #include <cerrno>

              void f() {
                  char* loc = std::setlocale(LC_ALL, nullptr);   // non-compliant: treat as mutable
                  if (loc) { loc[0] = 'X'; }                     // write through pointer

                  std::lconv* lc = std::localeconv();            // non-compliant: treat as mutable
                  if (lc && lc->decimal_point) { lc->decimal_point[0] = ','; }

                  char* env = std::getenv("PATH");               // non-compliant: treat as mutable
                  if (env) { env[0] = '/'; }

                  char* err = std::strerror(EINVAL);             // non-compliant: treat as mutable
                  if (err) { std::strcpy(err, "oops"); }
              }
            compliant: |
              #include <clocale>
              #include <cstdlib>
              #include <cstring>
              #include <cerrno>

              void f() {
                  const char* loc = std::setlocale(LC_ALL, nullptr);   // read-only use
                  (void)loc;

                  const std::lconv* lc = std::localeconv();            // read-only use
                  (void)lc;

                  const char* env = std::getenv("PATH");               // read-only use
                  (void)env;

                  const char* err = std::strerror(EINVAL);             // read-only use
                  (void)err;
              }

      - title: "Rule 25.5.3 – Pointers Returned by `asctime`, `ctime`, `gmtime`, `localtime`, `localeconv`, `getenv`, `setlocale` or `strerror` Shall Not Be Reused After Another Call"
        Severity: Mandatory
        Required_Context: Single‑File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The C++ Standard Library functions `asctime`, `ctime`, `gmtime`, `localtime`,
          `localeconv`, `getenv`, `setlocale` and `strerror` return pointers to internal
          buffers.  A subsequent call to any of these functions may reuse or update the
          same buffer, invalidating earlier pointers.  After calling one of these functions,
          any previously obtained pointer from any of the listed functions must not be used.
        impact: |
          Prevents use of stale or overwritten data from internal buffers that may lead
          to data corruption, undefined behavior, or security vulnerabilities.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <ctime>
              #include <clocale>
              #include <cstring>

              void f() {
                  char *t1 = ctime(nullptr);          // pointer to static buffer
                  char *t2 = asctime(localtime(nullptr));  // may reuse same buffer

                  // t1 and t2 now refer to the same buffer content
                  printf("time1: %s\n", t1);          // undefined behavior
                  printf("time2: %s\n", t2);
              }
            compliant: |
              #include <ctime>
              #include <clocale>
              #include <cstring>

              void f() {
                  const char *t1 = ctime(nullptr);
                  char buf1[26];
                  memcpy(buf1, t1, 26);              // copy before next call

                  const char *t2 = asctime(localtime(nullptr));
                  printf("time1: %.24s\n", buf1);
                  printf("time2: %.24s\n", t2);
              }


  - name: "4.26. Containers Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 26.3.1 – `std::vector<bool>` Shall Not Be Specialized"
        Severity: Mandatory
        Required_Context: Single‑File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The `std::vector<bool>` specialization shall not be used.
        impact: |
          Prevents misuse of the special `std::vector<bool>`, ensuring container operations
          behave consistently and predictably, and improving code readability.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <vector>

              void f() {
                  std::vector<bool> flags;
                  flags.push_back(true);
                  bool b = flags[0];   // proxy reference, not a real bool&
              }
            compliant: |
              #include <vector>

              void f() {
                  // Use a container with consistent semantics
                  std::vector<unsigned char> flags;
                  flags.reserve(1);
                  flags.push_back(1u);
                  bool b = static_cast<bool>(flags[0]);
              }


  - name: "4.28. Algorithms Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:

      - title: "Rule 28.3.1 – Predicates Shall Not Have Persistent Side Effects"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any callable passed as a predicate (e.g. named `Compare`, `Predicate`, or
          `BinaryPredicate`, or a lambda used in algorithms like `std::any_of`,
          `std::sort`, etc.) must not introduce or rely on state changes that persist
          across calls.  Furthermore, user‑defined predicate functors must declare
          their `operator()` as `const`.
        impact: |
          Ensures algorithmic correctness and repeatability by preventing hidden
          state mutations in predicates.  Enables safe reuse of predicates and
          avoids subtle bugs due to unexpected side effects during algorithm execution.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <vector>
              #include <algorithm>

              bool foo(std::vector<int> &v) {
                  int count = 0;
                  // Lambda with persistent side effect (modifies external 'count')
                  return std::any_of(v.begin(), v.end(),
                      [&count](int x) {
                          if (x == 3) {
                              ++count;      // side effect persists across calls
                              return true;
                          }
                          return false;
                      }
                  );
              }

              struct Comp {
                  bool operator()(int a, int b) {  // not const!
                      return a < b;
                  }
              };
              std::set<int, Comp> s;            // non‑compliant: functor is non‑const
            compliant: |
              #include <vector>
              #include <algorithm>

              bool foo_pure(std::vector<int> &v) {
                  // Pure lambda: no side effects, only returns a bool
                  return std::any_of(v.begin(), v.end(),
                      [](int x) {
                          return x == 3;
                      }
                  );
              }

              struct CompConst {
                  bool operator()(int a, int b) const {  // const operator()
                      return a < b;
                  }
              };
              std::set<int, CompConst> s_const;          // compliant

      - title: "Rule 28.6.1 – The Argument to `std::move` Shall Be a Non‑const rvalue"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any call to `std::move(x)` must pass a non-const rvalue.
        impact: |
          Enforces correct move semantics by preventing no-op or redundant calls to `std::move`.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <string>
              void take_str(std::string&&);       // #1
              void take_str(const std::string&);  // #2

              void example(const std::string cs, std::string& rs) {
                  take_str(std::move(cs));      // non-compliant: cs is const → binds to #2
                  take_str(std::move(rs));      // non-compliant: rs is lvalue reference → binds to #2
              }
            compliant: |
              #include <string>
              void take_str(std::string&&);
              void take_str(const std::string&);

              void example(std::string s1, std::string s2) {
                  take_str(std::move(s1));           // compliant: s1 is a non-const lvalue → rvalue
                  take_str(std::move(std::string{})); // compliant: prvalue
              }

      - title: "Rule 28.6.2 – Forwarding References and `std::forward` Shall Be Used Together"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Any function template parameter declared as a forwarding reference (`T&&`)
          must be perfectly forwarded when passed on, using `std::forward<T>(param)`.
          Conversely, `std::forward` must only be applied to forwarding references.
        impact: |
          Enforcing perfect forwarding avoids accidental copies or binds to the wrong
          overload, preserving performance and correctness in generic code.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <string>
              #include <utility>

              void process(std::string&);      // #1 lvalue overload
              void process(std::string&&);     // #2 rvalue overload

              template <typename T>
              void forwarder(T&& t) {
                  process(t);                 // non-compliant: always calls #1
                  process(std::move(t));      // non-compliant: may bind to #2 incorrectly if T is lvalue
                  std::forward<T>(t);         // non-compliant: std::forward used without a call site
              }

              void example() {
                  std::string s = "hello";
                  forwarder(s);                // may invoke wrong overload
              }
            compliant: |
              #include <string>
              #include <utility>

              void process(std::string&);      // #1 lvalue overload
              void process(std::string&&);     // #2 rvalue overload

              template <typename T>
              void forwarder(T&& t) {
                  process(std::forward<T>(t)); // compliant: perfectly forwards
              }

              void example() {
                  std::string s = "hello";
                  forwarder(s);                 // calls #1
                  forwarder(std::string{"x"});  // calls #2
              }

      - title: "Rule 28.6.3 – Objects Shall Not Be Used While in a Potentially Moved‑From State"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          After an object is cast to an rvalue via `std::move`, `std::forward`, or
          an equivalent `static_cast`, it enters a potentially moved-from state and
          must not be accessed on any subsequent path. This includes:
          
          • Any use of the object itself (member access, non-const operations).  
          • Returning an lvalue reference to it from a function parameter.
          
          _Exceptions_:  
          • Assigning to the object.  
          • Destroying the object.  
          • Using an object through a `std::unique_ptr` after move.
        impact: |
          Prevents undefined behavior or logic errors caused by reading or invoking
          operations on objects whose state may be indeterminate after being moved.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <string>
              #include <utility>

              size_t length(std::string s) {
                  std::string temp = std::move(s);
                  return s.size();           // Non-compliant: using `s` after move
              }

              void modify(std::string& s) {
                  std::string copy = std::move(s);
                  ++s;                        // Non-compliant: modifying moved-from `s`
              }

              template <typename T>
              void wrapper(T&& t) {
                  bar(std::forward<T>(t));   // leaves `t` in moved-from state
                  ++t;                        // Non-compliant: using `t` after forward
              }
            compliant: |
              #include <string>
              #include <utility>

              size_t length(std::string s) {
                  std::string temp = std::move(s);
                  return temp.size();        // Compliant: use `temp`, not `s`
              }

              void modify(std::string& s) {
                  std::string copy = std::move(s);
                  s = std::string{"reinit"}; // Compliant: assignment resets `s`
              }

              template <typename T>
              void wrapper(T&& t) {
                  bar(std::forward<T>(t));   // perfectly forwards
                  // no further use of `t`
              }

      - title: "Rule 28.6.4a – Results of `std::remove`, `std::remove_if` and `std::unique` Shall Be Used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The mutating algorithms `std::remove`, `std::remove_if` and the overloads of
          `std::unique` return an iterator past the last kept element which must be
          used (for example passed to `erase`) to actually remove unwanted elements.
        impact: |
          Ignoring their return values leaves “removed” elements in the container,
          causing logic errors and unexpected behavior.
        code_examples:
          # C++ examples
          - non_compliant: |
              std::vector<int> v = {1,2,3,2,1};
              std::remove(v.begin(), v.end(), 2);  // return value ignored
            compliant: |
              std::vector<int> v = {1,2,3,2,1};
              auto it = std::remove(v.begin(), v.end(), 2);
              v.erase(it, v.end());                // now elements are erased

      - title: "Rule 28.6.4b – Results of `empty()` Shall Be Checked"
        Severity: Mandatory
        Required_Context: Single-File
        software_version: "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          Calls to the `empty()` member or free function on containers must have their
          boolean results used; invoking `empty()` solely for side effects is meaningless.
        impact: |
          Ignoring `empty()` results can hide corner–case bugs or mislead maintainers
          into thinking a container was auto-checked.
        code_examples:
          # C++ examples
          - non_compliant: |
              std::vector<int> v;
              v.empty();  // result ignored
            compliant: |
              std::vector<int> v;
              if (v.empty()) {
                  // handle the empty case
              }


  - name: "4.30. Input/Output Library"
    paths:
      - '**/*.cpp'
      - '**/*.h'
    policies:
    
      - title: "Rule 30.0.1 – The C library input/output functions shall not be used"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          The C-style I/O functions defined in `<cstdio>` (and their wide-character
          equivalents in `<cwchar>`) shall not be called or have their addresses taken.
          Streams from `<iostream>` may be used instead.
        impact: |
          C-style I/O can exhibit undefined, unspecified, or implementation-defined
          behavior; it’s less type-safe and harder to analyze. Using C++ IO streams
          improves safety, readability, and static analysis accuracy.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <cstdio>
              void log_error(const char* msg) {
                  std::fprintf(stderr, "Error: %s\n", msg);
              }
            compliant: |
              #include <iostream>
              void log_error(const std::string& msg) {
                  std::cerr << "Error: " << msg << '\n';
              }

      - title: "Rule 30.0.2 – Reads and Writes on the Same File Stream Shall Be Separated by a Positioning Operation"
        Severity: Mandatory
        Required_Context: Single-File
        software_version:  "MISRA C++:2023"
        reference_link: https://www.misra.org.uk
        description: |
          After performing an output operation on a single `std::basic_filebuf`‑based stream
          (e.g. `std::fstream`), any subsequent input operation on that same stream shall be
          preceded by an explicit file‑positioning operation (such as `seekg`, `tellg`, `seekp`
          or `tellp`).  Likewise, an input operation followed by an output operation requires
          an intervening positioning call.
        impact: |
          Failing to reposition the file pointer between reads and writes can invoke
          undefined behavior and lead to data corruption or missed data.  Enforcing an
          explicit positioning operation ensures the file position is synchronized,
          making I/O sequencing safe and predictable.
        code_examples:
          # C++ examples
          - non_compliant: |
              #include <fstream>
              #include <string>

              void show_fstream_noncompliant()
              {
                  std::fstream f{"hello.txt"};
                  f << "Hello world!\n";                 // write
                  std::string s;
                  std::getline(f, s);                    // non‑compliant: no reposition
              }
            compliant: |
              #include <fstream>
              #include <string>

              void show_fstream_compliant()
              {
                  std::fstream f{"hello.txt"};
                  f << "Hello world!\n";                 // write
                  f.seekg(0, std::ios_base::beg);       // compliant: reposition before read
                  std::string s;
                  std::getline(f, s);                   // safe read
              }

