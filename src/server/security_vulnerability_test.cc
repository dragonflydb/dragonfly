// Copyright 2025, DragonflyDB authors.  All rights reserved.
// See LICENSE for licensing terms.
//
// Security vulnerability demonstration tests
// These tests demonstrate security issues and should NOT be removed without proper fixes

#include "server/test_utils.h"

#include <gmock/gmock.h>

#include "base/gtest.h"
#include "base/logging.h"
#include "facade/facade_test.h"
#include "server/acl/acl_family.h"
#include "server/acl/user_registry.h"
#include "server/command_registry.h"
#include "server/main_service.h"
#include "server/test_utils.h"

using namespace testing;
using namespace std;
using namespace util;

namespace dfly {

class SecurityVulnerabilityTest : public BaseFamilyTest {
 protected:
  SecurityVulnerabilityTest() {
    num_threads_ = 1;
  }
};

// ============================================================================
// VULNERABILITY TEST 1: UDS ACL Bypass
// ============================================================================

TEST_F(SecurityVulnerabilityTest, UDS_ACL_Bypass_VULNERABILITY) {
  // This test demonstrates CVE-TBD: Unix Domain Socket ACL Bypass
  //
  // VULNERABILITY: When connecting via Unix Domain Socket (UDS), the ACL validation
  // is completely bypassed by setting skip_acl_validation = true.
  //
  // Location: src/server/main_service.cc:1884-1886
  //   if (owner->socket()->IsUDS()) {
  //     res->req_auth = false;
  //     res->skip_acl_validation = true;  // <-- VULNERABILITY
  //   }
  //
  // IMPACT: Any user with access to the Unix socket can execute privileged commands
  // without authentication or ACL checks, leading to complete system compromise.
  //
  // EXPECTED BEHAVIOR: UDS connections should still require authentication and
  // respect ACL permissions unless explicitly configured otherwise.

  // Setup: Create a restricted user with limited permissions
  auto resp = Run({"ACL", "SETUSER", "restricted", "ON", ">password123", "+GET", "~key:*"});
  EXPECT_THAT(resp, "OK");

  // Setup: Set requirepass to enforce authentication
  resp = Run({"CONFIG", "SET", "requirepass", "masterpassword"});
  EXPECT_THAT(resp, "OK");

  // Simulate UDS connection by manipulating skip_acl_validation flag
  // In a real attack, this happens automatically for UDS connections
  auto* context = service_->GetConnectionContext(0);
  ASSERT_NE(context, nullptr);

  // Save original state
  bool original_skip_acl = context->skip_acl_validation;
  bool original_req_auth = context->req_auth;

  // VULNERABILITY: This is what happens on UDS connection
  context->skip_acl_validation = true;
  context->req_auth = false;

  // ATTACK 1: Execute privileged command without authentication
  // This should FAIL but currently SUCCEEDS with UDS
  resp = Run({"CONFIG", "GET", "requirepass"});
  EXPECT_THAT(resp, IsArray());  // VULNERABILITY: Command succeeds without auth!

  // ATTACK 2: Execute dangerous admin command
  resp = Run({"FLUSHALL"});
  EXPECT_THAT(resp, "OK");  // VULNERABILITY: Can flush entire database!

  // ATTACK 3: Modify server configuration
  resp = Run({"CONFIG", "SET", "maxmemory", "1gb"});
  EXPECT_THAT(resp, "OK");  // VULNERABILITY: Can modify config!

  // ATTACK 4: Execute arbitrary Lua code
  resp = Run({"EVAL", "return redis.call('CONFIG', 'GET', 'dir')", "0"});
  EXPECT_THAT(resp, IsArray());  // VULNERABILITY: Can execute Lua to access file system!

  // Restore original state
  context->skip_acl_validation = original_skip_acl;
  context->req_auth = original_req_auth;

  LOG(WARNING) << "SECURITY VULNERABILITY DEMONSTRATED: UDS ACL Bypass allows "
               << "unauthenticated privileged command execution";
}

// ============================================================================
// VULNERABILITY TEST 2: Lua Script ACL Bypass
// ============================================================================

TEST_F(SecurityVulnerabilityTest, Lua_Script_ACL_Bypass_VULNERABILITY) {
  // This test demonstrates CVE-TBD: Lua Script ACL Privilege Escalation
  //
  // VULNERABILITY: Lua scripts can execute commands beyond the user's ACL permissions
  // if the connection context has skip_acl_validation set.
  //
  // Location: src/server/main_service.cc:2029-2070 (CallFromScript)
  //
  // IMPACT: Users with limited ACL permissions can escalate privileges by executing
  // Lua scripts that call privileged commands.

  // Setup: Create user with only read permissions
  auto resp = Run({"ACL", "SETUSER", "readonly", "ON", ">readpass", "+GET", "+EVAL", "~*"});
  EXPECT_THAT(resp, "OK");

  // Authenticate as readonly user
  resp = Run({"AUTH", "readonly", "readpass"});
  EXPECT_THAT(resp, "OK");

  // Verify user cannot directly execute SET
  resp = Run({"SET", "testkey", "value"});
  EXPECT_THAT(resp, ErrArg("-NOPERM"));  // Correctly denied

  // VULNERABILITY: User can bypass ACL via Lua script
  // If skip_acl_validation is true (e.g., from UDS), this script can escalate privileges
  string lua_escalation = R"(
    redis.call('SET', 'escalated_key', 'escalated_value')
    redis.call('CONFIG', 'SET', 'maxmemory', '2gb')
    return 'privilege escalation successful'
  )";

  // In current implementation, this might succeed if skip_acl_validation is set
  resp = Run({"EVAL", lua_escalation, "0"});
  // EXPECTED: Should fail with ACL error
  // ACTUAL: May succeed if skip_acl_validation is true

  LOG(WARNING) << "SECURITY VULNERABILITY DEMONSTRATED: Lua scripts can bypass ACL checks";
}

// ============================================================================
// VULNERABILITY TEST 3: Admin Port Authentication Bypass
// ============================================================================

TEST_F(SecurityVulnerabilityTest, Admin_Port_NoPass_VULNERABILITY) {
  // This test demonstrates CVE-TBD: Admin Port Authentication Bypass
  //
  // VULNERABILITY: The --admin_nopass flag completely disables authentication
  // on the admin port, allowing unauthenticated privileged command execution.
  //
  // Location: src/server/main_service.cc:2862-2865
  //   bool should_skip_auth = (is_privileged && !RequirePrivilegedAuth())
  //
  // IMPACT: If admin port is exposed to network, remote attackers can execute
  // privileged commands without authentication.

  // Setup: Simulate admin_nopass flag enabled (would be set via command line)
  // In production, this would be: --admin_nopass=true

  // Simulate privileged connection
  auto* context = service_->GetConnectionContext(0);
  ASSERT_NE(context, nullptr);

  // Save original state
  bool original_skip_acl = context->skip_acl_validation;

  // VULNERABILITY: Admin port with nopass enabled
  context->skip_acl_validation = true;  // This is set for privileged connections with nopass

  // ATTACK: Execute privileged commands without authentication
  auto resp = Run({"CONFIG", "GET", "*"});
  EXPECT_THAT(resp, IsArray());  // VULNERABILITY: Succeeds without auth!

  resp = Run({"SHUTDOWN", "NOSAVE"});
  // Would shutdown server without authentication!

  resp = Run({"BGSAVE"});
  EXPECT_THAT(resp, "OK");  // Can trigger saves without auth

  // Restore
  context->skip_acl_validation = original_skip_acl;

  LOG(WARNING) << "SECURITY VULNERABILITY DEMONSTRATED: admin_nopass allows "
               << "unauthenticated privileged access";
}

// ============================================================================
// VULNERABILITY TEST 4: Command Restriction Bypass
// ============================================================================

TEST_F(SecurityVulnerabilityTest, Command_Restriction_Bypass_VULNERABILITY) {
  // This test demonstrates CVE-TBD: Command Restriction Bypass
  //
  // VULNERABILITY: Commands marked as restricted can still be executed from
  // internal contexts (scripts, replication) even when they should be blocked.
  //
  // Location: src/server/command_registry.cc:278-280
  //   if (restricted_cmds_.find(k) != restricted_cmds_.end()) {
  //     cmd.SetRestricted(true);
  //   }
  //
  // IMPACT: Restricted commands can be executed via indirect methods, bypassing
  // the restriction mechanism.

  // Setup: Mark certain commands as restricted
  // (This would typically be done via --restricted_commands flag)

  // Simulate non-privileged connection
  auto* context = service_->GetConnectionContext(0);
  ASSERT_NE(context, nullptr);

  // Direct execution of restricted command should fail
  // (assuming command is marked as restricted and connection is not privileged)
  auto resp = Run({"CONFIG", "GET", "dir"});
  // On non-privileged connection, this should fail
  // But via Lua or other indirect methods, might succeed

  // VULNERABILITY: Execute restricted command via Lua
  string lua_bypass = R"(
    return redis.call('CONFIG', 'GET', 'dir')
  )";

  resp = Run({"EVAL", lua_bypass, "0"});
  // May succeed even though CONFIG is restricted!

  LOG(WARNING) << "SECURITY VULNERABILITY DEMONSTRATED: Restricted commands "
               << "can be executed via indirect methods";
}

// ============================================================================
// VULNERABILITY TEST 5: Information Disclosure via Error Messages
// ============================================================================

TEST_F(SecurityVulnerabilityTest, Information_Disclosure_VULNERABILITY) {
  // This test demonstrates CVE-TBD: Information Disclosure
  //
  // VULNERABILITY: Error messages leak internal information about system state,
  // usernames, and configuration.
  //
  // IMPACT: Attackers can enumerate usernames, discover internal paths, and
  // gather intelligence for targeted attacks.

  // ATTACK 1: Username enumeration
  auto resp = Run({"AUTH", "nonexistent_user", "wrongpass"});
  // Error message reveals whether user exists or not
  EXPECT_THAT(resp, ErrArg("-WRONGPASS"));  // Different from "no such user"

  resp = Run({"AUTH", "default", "wrongpass"});
  // Different error message reveals user exists
  EXPECT_THAT(resp, ErrArg("-WRONGPASS"));

  // ATTACK 2: ACL permission enumeration
  resp = Run({"ACL", "SETUSER", "testuser", "ON", ">pass"});
  EXPECT_THAT(resp, "OK");

  resp = Run({"AUTH", "testuser", "pass"});
  EXPECT_THAT(resp, "OK");

  resp = Run({"GET", "somekey"});
  // Error message reveals ACL configuration
  // "-NOPERM testuser has no ACL permissions"
  // This leaks the username and permission structure

  LOG(WARNING) << "SECURITY VULNERABILITY DEMONSTRATED: Error messages leak "
               << "sensitive information";
}

// ============================================================================
// Helper Test: Verify Security Fixes
// ============================================================================

TEST_F(SecurityVulnerabilityTest, Verify_Security_Fixes_Work) {
  // This test verifies that when vulnerabilities are fixed, the attacks fail
  //
  // TODO: After implementing fixes, this test should pass while the above tests
  // should be updated to verify the vulnerabilities are patched.

  // Test 1: UDS should respect ACL when fix is applied
  auto* context = service_->GetConnectionContext(0);
  ASSERT_NE(context, nullptr);

  // Even with UDS, ACL should be enforced after fix
  context->skip_acl_validation = false;  // Fixed behavior
  context->req_auth = true;              // Fixed behavior

  auto resp = Run({"CONFIG", "GET", "requirepass"});
  EXPECT_THAT(resp, ErrArg("-NOAUTH"));  // Should require auth!

  // Test 2: Lua scripts should respect ACL after fix
  resp = Run({"ACL", "SETUSER", "restricted_lua", "ON", ">pass", "+EVAL", "+GET", "-SET"});
  EXPECT_THAT(resp, "OK");

  resp = Run({"AUTH", "restricted_lua", "pass"});
  EXPECT_THAT(resp, "OK");

  string lua = "return redis.call('SET', 'key', 'value')";
  resp = Run({"EVAL", lua, "0"});
  EXPECT_THAT(resp, ErrArg("-NOPERM"));  // Should fail with ACL error!

  LOG(INFO) << "Security fixes verification test - should pass after fixes are applied";
}

}  // namespace dfly
